<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>openitcockpit-agent.src.checks.default_checks API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>openitcockpit-agent.src.checks.default_checks</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import os
import sys
import traceback
import platform
import psutil
import time
from contextlib import contextmanager

from src.checks.Check import Check

if sys.platform == &#39;win32&#39; or sys.platform == &#39;win64&#39;:
    import win32evtlog
    import win32evtlogutil
    import win32con
    import win32security  # To translate NT Sids to account names.

from src.operating_system import OperatingSystem


class DefaultChecks(Check):

    def __init__(self, config, agent_log, check_store, check_params):
        super().__init__(config, agent_log, check_store, check_params)
        self.operating_system = OperatingSystem()

        self.key_name = &#34;default_checks&#34;

        self.cached_diskIO = {}
        self.cached_netIO = {}

    def run_check(self) -&gt; dict:
        &#34;&#34;&#34;Function to run the default checks

        Run default checks to get following information points.


        - disks (Storage devices with mountpoint, filesystem and storage space definitions)
        - disk_io (Read and write statistics of the storage devices)
        - net_io (Input and Outputstatistics of the network devices)
        - net_stats (Network devices including the possible speed, ...)
        - sensors (Connected sensors, e.g. temperature of the cpu, akku state)
        - cpu_total_percentage (Used CPU calculation time in percent)
        - cpu_percentage (Used cpu calculation time in percent per core)
        - cpu_total_percentage_detailed (Cpu calculation time in percent per system ressource)
        - cpu_percentage_detailed (Cpu calculation time in percent per system ressource per core)
        - system_load (System load 1, 5, 15 as array)
        - users (Users logged on to the system, their terminals (pid), login time)
        - memory (Memory information, total, used, active, buffered, ...)
        - swap (Swap information, total, used, ...)
        - processes (Information to running processes, cpu, memory, pid, ...)
        - agent (Agent version, last check time, system version, ...)
        - dockerstats (Docker containers, id, cpu, memory, block io, pid)
        - qemustats (Information to active QEMU virtual machines)


        Notice:

        Processes with id 0 or 1 are excluded of the process parent and child id check.
        There are the root processes on linux, macOS and windows.
        These checks are configurable: dockerstats, qemustats, cpustats, sensorstats, processstats, netstats, diskstats, netio, diskio, winservices.
        Average values and iops in netio and diskio checks are available after the second check goes through.


        Returns
        -------
        dict
            Object (dictionary) containing all the default check results

        &#34;&#34;&#34;
        self.agent_log.verbose(&#39;Running default checks&#39;)

        # if verbose:
        #    print_lock.acquire()

        if self.Config.config.getboolean(&#39;default&#39;, &#39;cpustats&#39;):
            # CPU #
            cpuTotalPercentage = psutil.cpu_percent()
            cpuPercentage = psutil.cpu_percent(interval=0, percpu=True)

            cpu = psutil.cpu_times_percent(interval=0, percpu=False)
            cpuTotalPercentageDetailed = cpu._asdict()

            cpuPercentageDetailed = [dict(cpu._asdict()) for cpu in
                                     psutil.cpu_times_percent(interval=0, percpu=True)]

        uptime = 0
        try:
            uptime = int(time.time() - psutil.boot_time())
        except:
            self.agent_log.error(&#34;Could not get system uptime!&#34;)

            if self.Config.stacktrace:
                traceback.print_exc()

        # totalCpus = psutil.cpu_count()
        # physicalCpus = psutil.cpu_count(logical=False)

        # cpuFrequency = psutil.cpu_freq()

        # MEMORY #

        memory = psutil.virtual_memory()
        swap = psutil.swap_memory()

        disks = []
        if self.Config.config.getboolean(&#39;default&#39;, &#39;diskstats&#39;):
            # DISKS #
            try:
                for disk in psutil.disk_partitions():
                    if self.operating_system.isWindows():
                        if &#39;cdrom&#39; in disk.opts or disk.fstype == &#39;&#39;:
                            # skip cd-rom drives with no disk in it; they may raise
                            # ENOENT, pop-up a Windows GUI error for a non-ready
                            # partition or just hang.
                            continue
                    disks.append(dict(
                        disk=disk._asdict(),
                        usage=psutil.disk_usage(disk.mountpoint)._asdict()
                    ))
            except:
                self.agent_log.error(&#34;Could not get system disks!&#34;)

                if self.Config.stacktrace:
                    traceback.print_exc()

        diskIO = None
        if hasattr(psutil, &#34;disk_io_counters&#34;) and self.Config.config.getboolean(&#39;default&#39;, &#39;diskio&#39;):
            try:
                # diskIOTotal = psutil.disk_io_counters(perdisk=False)._asdict()
                # diskIO = psutil.disk_io_counters(perdisk=True)
                diskIO = {disk: iops._asdict() for disk, iops in psutil.disk_io_counters(perdisk=True).items()}
                diskIO[&#39;timestamp&#39;] = time.time()

                for disk in diskIO:
                    if disk != &#34;timestamp&#34; and disk in self.cached_diskIO:

                        diskIODiff = {}
                        diskIODiff[&#39;timestamp&#39;] = self.wrapdiff(float(self.cached_diskIO[&#39;timestamp&#39;]),
                                                                float(diskIO[&#39;timestamp&#39;]))

                        for attr in diskIO[disk]:
                            diff = self.wrapdiff(float(self.cached_diskIO[disk][attr]), float(diskIO[disk][attr]))
                            diskIODiff[attr] = diff

                        diskIO[disk][&#39;read_iops&#39;] = diskIODiff[&#39;read_count&#39;] / diskIODiff[&#39;timestamp&#39;]
                        diskIO[disk][&#39;write_iops&#39;] = diskIODiff[&#39;write_count&#39;] / diskIODiff[&#39;timestamp&#39;]

                        tot_ios = diskIODiff[&#39;read_count&#39;] + diskIODiff[&#39;write_count&#39;]
                        diskIO[disk][&#39;total_iops&#39;] = tot_ios / diskIODiff[&#39;timestamp&#39;]
                        # diskIO[disk][&#39;tot_ticks&#39;] = diskIODiff[&#39;busy_time&#39;]
                        # diskIO[disk][&#39;interval&#39;] = diskIODiff[&#39;timestamp&#39;]
                        if &#39;busy_time&#39; in diskIODiff:
                            diskIO[disk][&#39;load_percent&#39;] = diskIODiff[&#39;busy_time&#39;] / (
                                    diskIODiff[&#39;timestamp&#39;] * 1000.) * 100.

                        if diskIODiff[&#39;read_count&#39;]:
                            diskIO[disk][&#39;read_avg_wait&#39;] = float(
                                diskIODiff[&#39;read_time&#39;] / diskIODiff[&#39;read_count&#39;])
                            diskIO[disk][&#39;read_avg_size&#39;] = float(
                                diskIODiff[&#39;read_bytes&#39;] / diskIODiff[&#39;read_count&#39;])
                        else:
                            diskIO[disk][&#39;read_avg_wait&#39;] = 0
                            diskIO[disk][&#39;read_avg_size&#39;] = 0

                        if diskIODiff[&#39;write_count&#39;]:
                            diskIO[disk][&#39;write_avg_wait&#39;] = float(
                                diskIODiff[&#39;write_time&#39;] / diskIODiff[&#39;write_count&#39;])
                            diskIO[disk][&#39;write_avg_size&#39;] = float(
                                diskIODiff[&#39;write_bytes&#39;] / diskIODiff[&#39;write_count&#39;])
                        else:
                            diskIO[disk][&#39;write_avg_wait&#39;] = 0
                            diskIO[disk][&#39;write_avg_size&#39;] = 0

                        if tot_ios:
                            diskIO[disk][&#39;total_avg_wait&#39;] = float(
                                (diskIODiff[&#39;read_time&#39;] + diskIODiff[&#39;write_time&#39;]) / tot_ios)
                        else:
                            diskIO[disk][&#39;total_avg_wait&#39;] = 0

                self.cached_diskIO = diskIO
            except:
                self.agent_log.error(&#34;Could not get disk io stats!&#34;)

                if self.Config.stacktrace:
                    traceback.print_exc()

        netIO = None
        if hasattr(psutil, &#34;net_io_counters&#34;) and self.Config.config.getboolean(&#39;default&#39;, &#39;netio&#39;):
            try:
                netIO = {device: data._asdict() for device, data in psutil.net_io_counters(pernic=True).items()}
                netIO[&#39;timestamp&#39;] = time.time()

                for device in netIO:
                    if device != &#34;timestamp&#34; and device in self.cached_netIO:

                        netIODiff = {}
                        netIODiff[&#39;timestamp&#39;] = self.wrapdiff(float(self.cached_netIO[&#39;timestamp&#39;]),
                                                               float(netIO[&#39;timestamp&#39;]))

                        for attr in netIO[device]:
                            diff = self.wrapdiff(float(self.cached_netIO[device][attr]), float(netIO[device][attr]))
                            netIODiff[attr] = diff

                        if netIODiff[&#39;bytes_sent&#39;]:
                            netIO[device][&#39;avg_bytes_sent_ps&#39;] = float(
                                netIODiff[&#39;bytes_sent&#39;] / netIODiff[&#39;timestamp&#39;])
                        else:
                            netIO[device][&#39;avg_bytes_sent_ps&#39;] = 0

                        if netIODiff[&#39;bytes_recv&#39;]:
                            netIO[device][&#39;avg_bytes_recv_ps&#39;] = float(
                                netIODiff[&#39;bytes_recv&#39;] / netIODiff[&#39;timestamp&#39;])
                        else:
                            netIO[device][&#39;avg_bytes_recv_ps&#39;] = 0

                        if netIODiff[&#39;packets_sent&#39;]:
                            netIO[device][&#39;avg_packets_sent_ps&#39;] = float(
                                netIODiff[&#39;packets_sent&#39;] / netIODiff[&#39;timestamp&#39;])
                        else:
                            netIO[device][&#39;avg_packets_sent_ps&#39;] = 0

                        if netIODiff[&#39;packets_recv&#39;]:
                            netIO[device][&#39;avg_packets_recv_ps&#39;] = float(
                                netIODiff[&#39;packets_recv&#39;] / netIODiff[&#39;timestamp&#39;])
                        else:
                            netIO[device][&#39;avg_packets_recv_ps&#39;] = 0

                        if netIODiff[&#39;errin&#39;]:
                            netIO[device][&#39;avg_errin&#39;] = float(netIODiff[&#39;errin&#39;] / netIODiff[&#39;timestamp&#39;])
                        else:
                            netIO[device][&#39;avg_errin&#39;] = 0

                        if netIODiff[&#39;errout&#39;]:
                            netIO[device][&#39;avg_errout&#39;] = float(netIODiff[&#39;errout&#39;] / netIODiff[&#39;timestamp&#39;])
                        else:
                            netIO[device][&#39;avg_errout&#39;] = 0

                        if netIODiff[&#39;dropin&#39;]:
                            netIO[device][&#39;avg_dropin&#39;] = float(netIODiff[&#39;dropin&#39;] / netIODiff[&#39;timestamp&#39;])
                        else:
                            netIO[device][&#39;avg_dropin&#39;] = 0

                        if netIODiff[&#39;dropout&#39;]:
                            netIO[device][&#39;avg_dropout&#39;] = float(netIODiff[&#39;dropout&#39;] / netIODiff[&#39;timestamp&#39;])
                        else:
                            netIO[device][&#39;avg_dropout&#39;] = 0

                self.cached_netIO = netIO
            except:
                self.agent_log.error(&#34;Could not get network io stats!&#34;)

                if self.Config.stacktrace:
                    traceback.print_exc()

        net_stats = None
        if hasattr(psutil, &#34;net_if_stats&#34;) and self.Config.config.getboolean(&#39;default&#39;, &#39;netstats&#39;):
            try:
                net_stats = {device: data._asdict() for device, data in psutil.net_if_stats().items()}
            except:
                self.agent_log.error(&#34;Could not get network device stats!&#34;)

                if self.Config.stacktrace:
                    traceback.print_exc()

        sensors = {}
        if self.Config.config.getboolean(&#39;default&#39;, &#39;sensorstats&#39;):
            try:
                if hasattr(psutil, &#34;sensors_temperatures&#34;) and self.operating_system.isWindows() is False:
                    sensors[&#39;temperatures&#39;] = {}
                    for device, data in psutil.sensors_temperatures(
                            fahrenheit=self.Config.temperatureIsFahrenheit).items():
                        sensors[&#39;temperatures&#39;][device] = []
                        for value in data:
                            sensors[&#39;temperatures&#39;][device].append(value._asdict())
                else:
                    sensors[&#39;temperatures&#39;] = {}
            except:
                self.agent_log.error(&#34;Could not get temperature sensor data!&#34;)

                if self.Config.stacktrace:
                    traceback.print_exc()

            try:
                if hasattr(psutil, &#34;sensors_fans&#34;) and self.operating_system.isWindows() is False:
                    sensors[&#39;fans&#39;] = {}
                    for device, data in psutil.sensors_fans().items():
                        sensors[&#39;fans&#39;][device] = []
                        for value in data:
                            sensors[&#39;fans&#39;][device].append(value._asdict())
                else:
                    sensors[&#39;fans&#39;] = {}
            except:
                self.agent_log.error(&#34;Could not get fans sensor data!&#34;)

                if self.Config.stacktrace:
                    traceback.print_exc()

            try:
                if hasattr(psutil, &#34;sensors_battery&#34;):
                    sensors_battery = psutil.sensors_battery()
                    if sensors_battery is not None:
                        sensors[&#39;battery&#39;] = sensors_battery._asdict()
                    else:
                        sensors[&#39;battery&#39;] = {}
                else:
                    sensors[&#39;battery&#39;] = {}
            except:
                self.agent_log.error(&#34;Could not get battery sensor data!&#34;)

                if self.Config.stacktrace:
                    traceback.print_exc()

        pids = psutil.pids()

        system_load_avg = []
        try:
            if hasattr(psutil, &#34;getloadavg&#34;):
                system_load_avg = psutil.getloadavg()
            elif hasattr(os, &#34;getloadavg&#34;):
                system_load_avg = os.getloadavg()
        except:
            self.agent_log.error(&#34;Could not get average system load!&#34;)

            if self.Config.stacktrace:
                traceback.print_exc()

        users = []
        try:
            if hasattr(psutil, &#34;users&#34;):
                users = [user._asdict() for user in psutil.users()]
        except:
            self.agent_log.error(&#34;Could not get users, connected to the system!&#34;)

            if self.Config.stacktrace:
                traceback.print_exc()

        # processes = [ psutil.Process(pid).as_dict() for pid in pids ]
        processes = []

        tmpProcessList = []

        if self.Config.config.getboolean(&#39;default&#39;, &#39;processstats&#39;):
            for pid in pids:
                try:
                    p = psutil.Process(pid)
                    try:
                        cpu_percent = p.cpu_percent(interval=None)

                        tmpProcessList.append(p)
                    except:
                        self.agent_log.verbose(&#34;&#39;%s&#39; Process is not allowing us to get the CPU usage!&#34; % str(pid))

                        if self.Config.stacktrace:
                            traceback.print_exc()


                except psutil.NoSuchProcess:
                    continue
                except:
                    self.agent_log.error(&#34;An error occured during process check!&#34;)

                    if self.Config.stacktrace:
                        traceback.print_exc()

        for p in tmpProcessList:
            try:

                pid = p.pid
                ppid = None
                status = &#34;&#34;
                username = &#34;&#34;
                nice = None
                name = &#34;&#34;
                exe = &#34;&#34;
                cmdline = &#34;&#34;
                cpu_percent = None
                memory_info = {}
                memory_percent = None
                num_fds = {}
                io_counters = {}
                open_files = &#34;&#34;
                children = []

                if pid not in (1, 2):
                    try:
                        if callable(p.parent):
                            ppid = p.parent().pid
                    except (psutil.NoSuchProcess, ProcessLookupError):
                        continue
                    except AttributeError:
                        self.agent_log.verbose(
                            &#34;&#39;%s&#39; Process is not allowing us to get the parent process id!&#34; % (str(pid)))

                        if self.Config.stacktrace:
                            traceback.print_exc()

                    if self.Config.config.getboolean(&#39;default&#39;, &#39;processstats-including-child-ids&#39;):
                        try:
                            if callable(p.children):
                                with self.suppress_stdout_stderr():
                                    for child in p.children(recursive=True):
                                        children.append(child.pid)
                        except:
                            self.agent_log.verbose(
                                &#34;&#39;%s&#39; Process is not allowing us to get the child process ids!&#34; % (str(pid)))

                            if self.Config.stacktrace:
                                traceback.print_exc()

                try:
                    nice = p.nice()
                except (psutil.NoSuchProcess, ProcessLookupError):
                    continue
                except:
                    self.agent_log.verbose(
                        &#34;&#39;%s&#39; Process is not allowing us to get the nice option!&#34; % (name if name != &#34;&#34; else str(pid)))

                    if self.Config.stacktrace:
                        traceback.print_exc()

                try:
                    name = p.name()
                except (psutil.NoSuchProcess, ProcessLookupError):
                    continue
                except:
                    self.agent_log.verbose(
                        &#34;&#39;%s&#39; Process is not allowing us to get the name option!&#34; % (name if name != &#34;&#34; else str(pid)))

                    if self.Config.stacktrace:
                        traceback.print_exc()

                try:
                    username = p.username()
                except (psutil.NoSuchProcess, ProcessLookupError):
                    continue
                except:
                    self.agent_log.verbose(&#34;&#39;%s&#39; Process is not allowing us to get the username option!&#34; % (
                        name if name != &#34;&#34; else str(pid)))

                    if self.Config.stacktrace:
                        traceback.print_exc()

                try:
                    exe = p.exe()
                except (psutil.NoSuchProcess, ProcessLookupError):
                    continue
                except:
                    self.agent_log.verbose(
                        &#34;&#39;%s&#39; Process is not allowing us to get the exec option!&#34; % (name if name != &#34;&#34; else str(pid)))

                    if self.Config.stacktrace:
                        traceback.print_exc()

                try:
                    cmdline = p.cmdline()
                except (psutil.NoSuchProcess, ProcessLookupError):
                    continue
                except:
                    self.agent_log.verbose(&#34;&#39;%s&#39; Process is not allowing us to get the cmdline option!&#34; % (
                        name if name != &#34;&#34; else str(pid)))

                    if self.Config.stacktrace:
                        traceback.print_exc()

                try:
                    cpu_percent = p.cpu_percent(interval=None)
                except (psutil.NoSuchProcess, ProcessLookupError):
                    continue
                except:
                    self.agent_log.verbose(
                        &#34;&#39;%s&#39; Process is not allowing us to get the CPU usage!&#34; % (name if name != &#34;&#34; else str(pid)))

                    if self.Config.stacktrace:
                        traceback.print_exc()

                try:
                    memory_info = p.memory_info()._asdict()
                except (psutil.NoSuchProcess, ProcessLookupError):
                    continue
                except:
                    self.agent_log.verbose(&#34;&#39;%s&#39; Process is not allowing us to get memory usage information!&#34; % (
                        name if name != &#34;&#34; else str(pid)))

                    if self.Config.stacktrace:
                        traceback.print_exc()

                try:
                    memory_percent = p.memory_percent()
                except (psutil.NoSuchProcess, ProcessLookupError):
                    continue
                except:
                    self.agent_log.verbose(&#34;&#39;%s&#39; Process is not allowing us to get the percent of memory usage!&#34; % (
                        name if name != &#34;&#34; else str(pid)))

                    if self.Config.stacktrace:
                        traceback.print_exc()

                try:
                    num_fds = p.num_fds()
                except (psutil.NoSuchProcess, ProcessLookupError):
                    continue
                except:
                    self.agent_log.verbose(&#34;&#39;%s&#39; Process is not allowing us to get the num_fds option!&#34; % (
                        name if name != &#34;&#34; else str(pid)))

                    if self.Config.stacktrace:
                        traceback.print_exc()

                try:
                    io_counters = p.io_counters.__dict__
                except (psutil.NoSuchProcess, ProcessLookupError):
                    continue
                except:
                    self.agent_log.verbose(
                        &#34;&#39;%s&#39; Process is not allowing us to get the IO counters!&#34; % (name if name != &#34;&#34; else str(pid)))

                    if self.Config.stacktrace:
                        traceback.print_exc()

                try:
                    open_files = p.open_files()
                except (psutil.NoSuchProcess, ProcessLookupError):
                    continue
                except psutil.AccessDenied:
                    self.agent_log.verbose(&#34;&#39;%s&#39; Process is not allowing us to get the open_files option!&#34; % (
                        name if name != &#34;&#34; else str(pid)))

                    if self.Config.stacktrace:
                        traceback.print_exc()

                name = name[:1000]
                exe = exe[:1000]
                cmdline = cmdline[:1000]

                process = {
                    &#39;name&#39;: name,
                    &#39;exec&#39;: exe,
                    &#39;cmdline&#39;: cmdline,
                    &#39;pid&#39;: pid,
                    &#39;ppid&#39;: ppid,
                    &#39;children&#39;: children,
                    &#39;status&#39;: status,
                    &#39;username&#39;: username,
                    &#39;cpu_percent&#39;: cpu_percent,
                    &#39;memory&#39;: memory_info,
                    &#39;memory_percent&#39;: memory_percent,
                    &#39;num_fds&#39;: num_fds,
                    &#39;open_files&#39;: open_files,
                    &#39;io_counters&#39;: io_counters,
                    &#39;nice_level&#39;: nice
                }
                processes.append(process)
            except psutil.NoSuchProcess:
                continue
            except:
                self.agent_log.error(&#34;An error occured during process check!&#34;)

                if self.Config.stacktrace:
                    traceback.print_exc()

        windows_services = []
        windows_eventlog = {}
        if self.operating_system.isWindows() is True:
            if self.Config.config.getboolean(&#39;default&#39;, &#39;winservices&#39;):
                try:
                    for win_process in psutil.win_service_iter():
                        windows_services.append(win_process.as_dict())
                except:
                    self.agent_log.error(&#34;An error occured during windows services check!&#34;)

                    if self.Config.stacktrace:
                        traceback.print_exc()

            if self.Config.config.getboolean(&#39;default&#39;, &#39;wineventlog&#39;):
                try:
                    server = &#39;localhost&#39;  # name of the target computer to get event logs
                    logTypes = []
                    if self.Config.config.get(&#39;default&#39;, &#39;wineventlog-logtypes&#39;) != &#34;&#34;:
                        for logtype in self.Config.config.get(&#39;default&#39;, &#39;wineventlog-logtypes&#39;).split(&#39;,&#39;):
                            if logtype.strip() != &#39;&#39;:
                                logTypes.append(logtype.strip())
                    else:
                        logTypes = [&#39;System&#39;, &#39;Application&#39;, &#39;Security&#39;, &#39;openITCOCKPIT Agent&#39;]

                    evt_dict = {
                        win32con.EVENTLOG_AUDIT_FAILURE: &#39;EVENTLOG_AUDIT_FAILURE&#39;,  # 16 -&gt; critical
                        win32con.EVENTLOG_AUDIT_SUCCESS: &#39;EVENTLOG_AUDIT_SUCCESS&#39;,  # 8  -&gt; ok
                        win32con.EVENTLOG_INFORMATION_TYPE: &#39;EVENTLOG_INFORMATION_TYPE&#39;,  # 4  -&gt; ok
                        win32con.EVENTLOG_WARNING_TYPE: &#39;EVENTLOG_WARNING_TYPE&#39;,  # 2  -&gt; warning
                        win32con.EVENTLOG_ERROR_TYPE: &#39;EVENTLOG_ERROR_TYPE&#39;  # 1  -&gt; critical
                    }

                    for logType in logTypes:
                        try:
                            if logType not in windows_eventlog:
                                windows_eventlog[logType] = []
                            hand = win32evtlog.OpenEventLog(server, logType)
                            flags = win32evtlog.EVENTLOG_BACKWARDS_READ | win32evtlog.EVENTLOG_SEQUENTIAL_READ
                            total = win32evtlog.GetNumberOfEventLogRecords(hand)
                            events = win32evtlog.ReadEventLog(hand, flags, 0)
                            if events:
                                for event in events:
                                    msg = win32evtlogutil.SafeFormatMessage(event, logType)
                                    sidDesc = None
                                    if event.Sid is not None:
                                        try:
                                            domain, user, typ = win32security.LookupAccountSid(server, event.Sid)
                                            sidDesc = &#34;%s/%s&#34; % (domain, user)
                                        except win32security.error:
                                            sidDesc = str(event.Sid)

                                    evt_type = &#34;unknown&#34;
                                    if event.EventType in evt_dict.keys():
                                        evt_type = str(evt_dict[event.EventType])

                                    tmp_evt = {
                                        &#39;event_category&#39;: event.EventCategory,
                                        &#39;time_generated&#39;: str(event.TimeGenerated),
                                        &#39;source_name&#39;: event.SourceName,
                                        &#39;associated_user&#39;: sidDesc,
                                        &#39;event_id&#39;: event.EventID,
                                        &#39;event_type&#39;: evt_type,
                                        &#39;event_type_id&#39;: event.EventType,
                                        &#39;event_msg&#39;: msg,
                                        &#39;event_data&#39;: [data for data in
                                                       event.StringInserts] if event.StringInserts else &#39;&#39;
                                    }
                                    windows_eventlog[logType].append(tmp_evt)
                        except:
                            self.agent_log.error(
                                &#34;An error occured during windows eventlog check with log type %s!&#34; % (logType))

                            if self.Config.stacktrace:
                                traceback.print_exc()

                except:
                    self.agent_log.error(&#34;An error occured during windows eventlog check!&#34;)

                    if self.Config.stacktrace:
                        traceback.print_exc()

        try:
            agent = {
                &#39;last_updated&#39;: time.ctime(),
                &#39;last_updated_timestamp&#39;: round(time.time()),
                &#39;system&#39;: platform.system(),
                &#39;system_uptime&#39;: uptime,
                &#39;kernel_version&#39;: platform.release(),
                &#39;mac_version&#39;: platform.mac_ver()[0],
                &#39;agent_version&#39;: self.Config.agentVersion,
                &#39;temperature_unit&#39;: &#39;F&#39; if self.Config.temperatureIsFahrenheit else &#39;C&#39;
            }
        except:
            agent = {
                &#39;last_updated&#39;: time.ctime(),
                &#39;last_updated_timestamp&#39;: round(time.time()),
                &#39;system_uptime&#39;: uptime,
                &#39;agent_version&#39;: self.Config.agentVersion,
                &#39;temperature_unit&#39;: &#39;F&#39; if self.Config.temperatureIsFahrenheit else &#39;C&#39;
            }

        out = {
            &#39;agent&#39;: agent,
            # &#39;disks&#39;: disks,
            # &#39;disk_io&#39;: diskIO,
            # &#39;disk_io_total&#39;: diskIOTotal,
            # &#39;net_stats&#39;: net_stats,
            # &#39;net_io&#39;: netIO,

            # &#39;sensors&#39;: sensors,

            # &#39;cpu_total_percentage&#39;: cpuTotalPercentage,
            # &#39;cpu_percentage&#39;: cpuPercentage,
            # &#39;cpu_total_percentage_detailed&#39;: cpuTotalPercentageDetailed,
            # &#39;cpu_percentage_detailed&#39;: cpuPercentageDetailed,

            &#39;system_load&#39;: system_load_avg,
            &#39;users&#39;: users,

            &#39;memory&#39;: memory._asdict(),
            &#39;swap&#39;: swap._asdict(),

            # &#39;processes&#39;: processes
        }

        if self.Config.config.getboolean(&#39;default&#39;, &#39;diskstats&#39;):
            out[&#39;disks&#39;] = disks

        if self.Config.config.getboolean(&#39;default&#39;, &#39;diskio&#39;):
            out[&#39;disk_io&#39;] = diskIO

        if self.Config.config.getboolean(&#39;default&#39;, &#39;netstats&#39;):
            out[&#39;net_stats&#39;] = net_stats

        if self.Config.config.getboolean(&#39;default&#39;, &#39;netio&#39;):
            out[&#39;net_io&#39;] = netIO

        if self.Config.config.getboolean(&#39;default&#39;, &#39;sensorstats&#39;):
            out[&#39;sensors&#39;] = sensors

        if self.Config.config.getboolean(&#39;default&#39;, &#39;cpustats&#39;):
            out[&#39;cpu_total_percentage&#39;] = cpuTotalPercentage
            out[&#39;cpu_percentage&#39;] = cpuPercentage
            out[&#39;cpu_total_percentage_detailed&#39;] = cpuTotalPercentageDetailed
            out[&#39;cpu_percentage_detailed&#39;] = cpuPercentageDetailed

        if self.Config.config.getboolean(&#39;default&#39;, &#39;processstats&#39;):
            out[&#39;processes&#39;] = processes

        if self.operating_system.isWindows() is True:
            if self.Config.config.getboolean(&#39;default&#39;, &#39;winservices&#39;):
                out[&#39;windows_services&#39;] = windows_services
            if self.Config.config.getboolean(&#39;default&#39;, &#39;wineventlog&#39;):
                out[&#39;windows_eventlog&#39;] = windows_eventlog

        # if len(systemd_services_data) &gt; 0:
        #    out[&#39;systemd_services&#39;] = systemd_services_data
        #
        # if len(cached_customchecks_check_data) &gt; 0:
        #    out[&#39;customchecks&#39;] = cached_customchecks_check_data
        #
        # if len(docker_stats_data) &gt; 0:
        #    out[&#39;dockerstats&#39;] = docker_stats_data
        #
        # if len(qemu_stats_data) &gt; 0:
        #    out[&#39;qemustats&#39;] = qemu_stats_data
        #
        # if &#39;result&#39; in alfresco_stats_data and config[&#39;default&#39;][&#39;alfrescostats&#39;] in (1, &#34;1&#34;, &#34;true&#34;, &#34;True&#34;):
        #    out[&#39;alfrescostats&#39;] = alfresco_stats_data[&#39;result&#39;]

        # if jmx_import_successfull and &#39;alfrescostats&#39; in config[&#39;default&#39;] and config[&#39;default&#39;][&#39;alfrescostats&#39;] in (1, &#34;1&#34;, &#34;true&#34;, &#34;True&#34;, True):
        #    out[&#39;alfrescostats&#39;] = alfrescostats
        # if self.Config.verbose:
        #    print_lock.release()

        return out

    def wrapdiff(self, last, curr):
        &#34;&#34;&#34; Function to calculate the difference between last and curr

            If last &gt; curr, try to guess the boundary at which the value must have wrapped
            by trying the maximum values of 64, 32 and 16 bit signed and unsigned ints.
        &#34;&#34;&#34;

        if last &lt;= curr:
            return float(curr - last)

        boundary = None
        for chkbound in (64, 63, 32, 31, 16, 15):
            if last &gt; 2 ** chkbound:
                break
            boundary = chkbound
        if boundary is None:
            raise ArithmeticError(&#34;Couldn&#39;t determine boundary&#34;)
        return float(2 ** boundary - last + curr)

    @contextmanager
    def suppress_stdout_stderr(self):
        &#34;&#34;&#34;A context manager that redirects stdout and stderr to devnull&#34;&#34;&#34;
        with open(os.devnull, &#34;w&#34;) as devnull:
            old_stdout = sys.stdout
            sys.stdout = devnull
            try:
                yield
            finally:
                sys.stdout = old_stdout</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="openitcockpit-agent.src.checks.default_checks.DefaultChecks"><code class="flex name class">
<span>class <span class="ident">DefaultChecks</span></span>
<span>(</span><span>config, agent_log, check_store, check_params)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DefaultChecks(Check):

    def __init__(self, config, agent_log, check_store, check_params):
        super().__init__(config, agent_log, check_store, check_params)
        self.operating_system = OperatingSystem()

        self.key_name = &#34;default_checks&#34;

        self.cached_diskIO = {}
        self.cached_netIO = {}

    def run_check(self) -&gt; dict:
        &#34;&#34;&#34;Function to run the default checks

        Run default checks to get following information points.


        - disks (Storage devices with mountpoint, filesystem and storage space definitions)
        - disk_io (Read and write statistics of the storage devices)
        - net_io (Input and Outputstatistics of the network devices)
        - net_stats (Network devices including the possible speed, ...)
        - sensors (Connected sensors, e.g. temperature of the cpu, akku state)
        - cpu_total_percentage (Used CPU calculation time in percent)
        - cpu_percentage (Used cpu calculation time in percent per core)
        - cpu_total_percentage_detailed (Cpu calculation time in percent per system ressource)
        - cpu_percentage_detailed (Cpu calculation time in percent per system ressource per core)
        - system_load (System load 1, 5, 15 as array)
        - users (Users logged on to the system, their terminals (pid), login time)
        - memory (Memory information, total, used, active, buffered, ...)
        - swap (Swap information, total, used, ...)
        - processes (Information to running processes, cpu, memory, pid, ...)
        - agent (Agent version, last check time, system version, ...)
        - dockerstats (Docker containers, id, cpu, memory, block io, pid)
        - qemustats (Information to active QEMU virtual machines)


        Notice:

        Processes with id 0 or 1 are excluded of the process parent and child id check.
        There are the root processes on linux, macOS and windows.
        These checks are configurable: dockerstats, qemustats, cpustats, sensorstats, processstats, netstats, diskstats, netio, diskio, winservices.
        Average values and iops in netio and diskio checks are available after the second check goes through.


        Returns
        -------
        dict
            Object (dictionary) containing all the default check results

        &#34;&#34;&#34;
        self.agent_log.verbose(&#39;Running default checks&#39;)

        # if verbose:
        #    print_lock.acquire()

        if self.Config.config.getboolean(&#39;default&#39;, &#39;cpustats&#39;):
            # CPU #
            cpuTotalPercentage = psutil.cpu_percent()
            cpuPercentage = psutil.cpu_percent(interval=0, percpu=True)

            cpu = psutil.cpu_times_percent(interval=0, percpu=False)
            cpuTotalPercentageDetailed = cpu._asdict()

            cpuPercentageDetailed = [dict(cpu._asdict()) for cpu in
                                     psutil.cpu_times_percent(interval=0, percpu=True)]

        uptime = 0
        try:
            uptime = int(time.time() - psutil.boot_time())
        except:
            self.agent_log.error(&#34;Could not get system uptime!&#34;)

            if self.Config.stacktrace:
                traceback.print_exc()

        # totalCpus = psutil.cpu_count()
        # physicalCpus = psutil.cpu_count(logical=False)

        # cpuFrequency = psutil.cpu_freq()

        # MEMORY #

        memory = psutil.virtual_memory()
        swap = psutil.swap_memory()

        disks = []
        if self.Config.config.getboolean(&#39;default&#39;, &#39;diskstats&#39;):
            # DISKS #
            try:
                for disk in psutil.disk_partitions():
                    if self.operating_system.isWindows():
                        if &#39;cdrom&#39; in disk.opts or disk.fstype == &#39;&#39;:
                            # skip cd-rom drives with no disk in it; they may raise
                            # ENOENT, pop-up a Windows GUI error for a non-ready
                            # partition or just hang.
                            continue
                    disks.append(dict(
                        disk=disk._asdict(),
                        usage=psutil.disk_usage(disk.mountpoint)._asdict()
                    ))
            except:
                self.agent_log.error(&#34;Could not get system disks!&#34;)

                if self.Config.stacktrace:
                    traceback.print_exc()

        diskIO = None
        if hasattr(psutil, &#34;disk_io_counters&#34;) and self.Config.config.getboolean(&#39;default&#39;, &#39;diskio&#39;):
            try:
                # diskIOTotal = psutil.disk_io_counters(perdisk=False)._asdict()
                # diskIO = psutil.disk_io_counters(perdisk=True)
                diskIO = {disk: iops._asdict() for disk, iops in psutil.disk_io_counters(perdisk=True).items()}
                diskIO[&#39;timestamp&#39;] = time.time()

                for disk in diskIO:
                    if disk != &#34;timestamp&#34; and disk in self.cached_diskIO:

                        diskIODiff = {}
                        diskIODiff[&#39;timestamp&#39;] = self.wrapdiff(float(self.cached_diskIO[&#39;timestamp&#39;]),
                                                                float(diskIO[&#39;timestamp&#39;]))

                        for attr in diskIO[disk]:
                            diff = self.wrapdiff(float(self.cached_diskIO[disk][attr]), float(diskIO[disk][attr]))
                            diskIODiff[attr] = diff

                        diskIO[disk][&#39;read_iops&#39;] = diskIODiff[&#39;read_count&#39;] / diskIODiff[&#39;timestamp&#39;]
                        diskIO[disk][&#39;write_iops&#39;] = diskIODiff[&#39;write_count&#39;] / diskIODiff[&#39;timestamp&#39;]

                        tot_ios = diskIODiff[&#39;read_count&#39;] + diskIODiff[&#39;write_count&#39;]
                        diskIO[disk][&#39;total_iops&#39;] = tot_ios / diskIODiff[&#39;timestamp&#39;]
                        # diskIO[disk][&#39;tot_ticks&#39;] = diskIODiff[&#39;busy_time&#39;]
                        # diskIO[disk][&#39;interval&#39;] = diskIODiff[&#39;timestamp&#39;]
                        if &#39;busy_time&#39; in diskIODiff:
                            diskIO[disk][&#39;load_percent&#39;] = diskIODiff[&#39;busy_time&#39;] / (
                                    diskIODiff[&#39;timestamp&#39;] * 1000.) * 100.

                        if diskIODiff[&#39;read_count&#39;]:
                            diskIO[disk][&#39;read_avg_wait&#39;] = float(
                                diskIODiff[&#39;read_time&#39;] / diskIODiff[&#39;read_count&#39;])
                            diskIO[disk][&#39;read_avg_size&#39;] = float(
                                diskIODiff[&#39;read_bytes&#39;] / diskIODiff[&#39;read_count&#39;])
                        else:
                            diskIO[disk][&#39;read_avg_wait&#39;] = 0
                            diskIO[disk][&#39;read_avg_size&#39;] = 0

                        if diskIODiff[&#39;write_count&#39;]:
                            diskIO[disk][&#39;write_avg_wait&#39;] = float(
                                diskIODiff[&#39;write_time&#39;] / diskIODiff[&#39;write_count&#39;])
                            diskIO[disk][&#39;write_avg_size&#39;] = float(
                                diskIODiff[&#39;write_bytes&#39;] / diskIODiff[&#39;write_count&#39;])
                        else:
                            diskIO[disk][&#39;write_avg_wait&#39;] = 0
                            diskIO[disk][&#39;write_avg_size&#39;] = 0

                        if tot_ios:
                            diskIO[disk][&#39;total_avg_wait&#39;] = float(
                                (diskIODiff[&#39;read_time&#39;] + diskIODiff[&#39;write_time&#39;]) / tot_ios)
                        else:
                            diskIO[disk][&#39;total_avg_wait&#39;] = 0

                self.cached_diskIO = diskIO
            except:
                self.agent_log.error(&#34;Could not get disk io stats!&#34;)

                if self.Config.stacktrace:
                    traceback.print_exc()

        netIO = None
        if hasattr(psutil, &#34;net_io_counters&#34;) and self.Config.config.getboolean(&#39;default&#39;, &#39;netio&#39;):
            try:
                netIO = {device: data._asdict() for device, data in psutil.net_io_counters(pernic=True).items()}
                netIO[&#39;timestamp&#39;] = time.time()

                for device in netIO:
                    if device != &#34;timestamp&#34; and device in self.cached_netIO:

                        netIODiff = {}
                        netIODiff[&#39;timestamp&#39;] = self.wrapdiff(float(self.cached_netIO[&#39;timestamp&#39;]),
                                                               float(netIO[&#39;timestamp&#39;]))

                        for attr in netIO[device]:
                            diff = self.wrapdiff(float(self.cached_netIO[device][attr]), float(netIO[device][attr]))
                            netIODiff[attr] = diff

                        if netIODiff[&#39;bytes_sent&#39;]:
                            netIO[device][&#39;avg_bytes_sent_ps&#39;] = float(
                                netIODiff[&#39;bytes_sent&#39;] / netIODiff[&#39;timestamp&#39;])
                        else:
                            netIO[device][&#39;avg_bytes_sent_ps&#39;] = 0

                        if netIODiff[&#39;bytes_recv&#39;]:
                            netIO[device][&#39;avg_bytes_recv_ps&#39;] = float(
                                netIODiff[&#39;bytes_recv&#39;] / netIODiff[&#39;timestamp&#39;])
                        else:
                            netIO[device][&#39;avg_bytes_recv_ps&#39;] = 0

                        if netIODiff[&#39;packets_sent&#39;]:
                            netIO[device][&#39;avg_packets_sent_ps&#39;] = float(
                                netIODiff[&#39;packets_sent&#39;] / netIODiff[&#39;timestamp&#39;])
                        else:
                            netIO[device][&#39;avg_packets_sent_ps&#39;] = 0

                        if netIODiff[&#39;packets_recv&#39;]:
                            netIO[device][&#39;avg_packets_recv_ps&#39;] = float(
                                netIODiff[&#39;packets_recv&#39;] / netIODiff[&#39;timestamp&#39;])
                        else:
                            netIO[device][&#39;avg_packets_recv_ps&#39;] = 0

                        if netIODiff[&#39;errin&#39;]:
                            netIO[device][&#39;avg_errin&#39;] = float(netIODiff[&#39;errin&#39;] / netIODiff[&#39;timestamp&#39;])
                        else:
                            netIO[device][&#39;avg_errin&#39;] = 0

                        if netIODiff[&#39;errout&#39;]:
                            netIO[device][&#39;avg_errout&#39;] = float(netIODiff[&#39;errout&#39;] / netIODiff[&#39;timestamp&#39;])
                        else:
                            netIO[device][&#39;avg_errout&#39;] = 0

                        if netIODiff[&#39;dropin&#39;]:
                            netIO[device][&#39;avg_dropin&#39;] = float(netIODiff[&#39;dropin&#39;] / netIODiff[&#39;timestamp&#39;])
                        else:
                            netIO[device][&#39;avg_dropin&#39;] = 0

                        if netIODiff[&#39;dropout&#39;]:
                            netIO[device][&#39;avg_dropout&#39;] = float(netIODiff[&#39;dropout&#39;] / netIODiff[&#39;timestamp&#39;])
                        else:
                            netIO[device][&#39;avg_dropout&#39;] = 0

                self.cached_netIO = netIO
            except:
                self.agent_log.error(&#34;Could not get network io stats!&#34;)

                if self.Config.stacktrace:
                    traceback.print_exc()

        net_stats = None
        if hasattr(psutil, &#34;net_if_stats&#34;) and self.Config.config.getboolean(&#39;default&#39;, &#39;netstats&#39;):
            try:
                net_stats = {device: data._asdict() for device, data in psutil.net_if_stats().items()}
            except:
                self.agent_log.error(&#34;Could not get network device stats!&#34;)

                if self.Config.stacktrace:
                    traceback.print_exc()

        sensors = {}
        if self.Config.config.getboolean(&#39;default&#39;, &#39;sensorstats&#39;):
            try:
                if hasattr(psutil, &#34;sensors_temperatures&#34;) and self.operating_system.isWindows() is False:
                    sensors[&#39;temperatures&#39;] = {}
                    for device, data in psutil.sensors_temperatures(
                            fahrenheit=self.Config.temperatureIsFahrenheit).items():
                        sensors[&#39;temperatures&#39;][device] = []
                        for value in data:
                            sensors[&#39;temperatures&#39;][device].append(value._asdict())
                else:
                    sensors[&#39;temperatures&#39;] = {}
            except:
                self.agent_log.error(&#34;Could not get temperature sensor data!&#34;)

                if self.Config.stacktrace:
                    traceback.print_exc()

            try:
                if hasattr(psutil, &#34;sensors_fans&#34;) and self.operating_system.isWindows() is False:
                    sensors[&#39;fans&#39;] = {}
                    for device, data in psutil.sensors_fans().items():
                        sensors[&#39;fans&#39;][device] = []
                        for value in data:
                            sensors[&#39;fans&#39;][device].append(value._asdict())
                else:
                    sensors[&#39;fans&#39;] = {}
            except:
                self.agent_log.error(&#34;Could not get fans sensor data!&#34;)

                if self.Config.stacktrace:
                    traceback.print_exc()

            try:
                if hasattr(psutil, &#34;sensors_battery&#34;):
                    sensors_battery = psutil.sensors_battery()
                    if sensors_battery is not None:
                        sensors[&#39;battery&#39;] = sensors_battery._asdict()
                    else:
                        sensors[&#39;battery&#39;] = {}
                else:
                    sensors[&#39;battery&#39;] = {}
            except:
                self.agent_log.error(&#34;Could not get battery sensor data!&#34;)

                if self.Config.stacktrace:
                    traceback.print_exc()

        pids = psutil.pids()

        system_load_avg = []
        try:
            if hasattr(psutil, &#34;getloadavg&#34;):
                system_load_avg = psutil.getloadavg()
            elif hasattr(os, &#34;getloadavg&#34;):
                system_load_avg = os.getloadavg()
        except:
            self.agent_log.error(&#34;Could not get average system load!&#34;)

            if self.Config.stacktrace:
                traceback.print_exc()

        users = []
        try:
            if hasattr(psutil, &#34;users&#34;):
                users = [user._asdict() for user in psutil.users()]
        except:
            self.agent_log.error(&#34;Could not get users, connected to the system!&#34;)

            if self.Config.stacktrace:
                traceback.print_exc()

        # processes = [ psutil.Process(pid).as_dict() for pid in pids ]
        processes = []

        tmpProcessList = []

        if self.Config.config.getboolean(&#39;default&#39;, &#39;processstats&#39;):
            for pid in pids:
                try:
                    p = psutil.Process(pid)
                    try:
                        cpu_percent = p.cpu_percent(interval=None)

                        tmpProcessList.append(p)
                    except:
                        self.agent_log.verbose(&#34;&#39;%s&#39; Process is not allowing us to get the CPU usage!&#34; % str(pid))

                        if self.Config.stacktrace:
                            traceback.print_exc()


                except psutil.NoSuchProcess:
                    continue
                except:
                    self.agent_log.error(&#34;An error occured during process check!&#34;)

                    if self.Config.stacktrace:
                        traceback.print_exc()

        for p in tmpProcessList:
            try:

                pid = p.pid
                ppid = None
                status = &#34;&#34;
                username = &#34;&#34;
                nice = None
                name = &#34;&#34;
                exe = &#34;&#34;
                cmdline = &#34;&#34;
                cpu_percent = None
                memory_info = {}
                memory_percent = None
                num_fds = {}
                io_counters = {}
                open_files = &#34;&#34;
                children = []

                if pid not in (1, 2):
                    try:
                        if callable(p.parent):
                            ppid = p.parent().pid
                    except (psutil.NoSuchProcess, ProcessLookupError):
                        continue
                    except AttributeError:
                        self.agent_log.verbose(
                            &#34;&#39;%s&#39; Process is not allowing us to get the parent process id!&#34; % (str(pid)))

                        if self.Config.stacktrace:
                            traceback.print_exc()

                    if self.Config.config.getboolean(&#39;default&#39;, &#39;processstats-including-child-ids&#39;):
                        try:
                            if callable(p.children):
                                with self.suppress_stdout_stderr():
                                    for child in p.children(recursive=True):
                                        children.append(child.pid)
                        except:
                            self.agent_log.verbose(
                                &#34;&#39;%s&#39; Process is not allowing us to get the child process ids!&#34; % (str(pid)))

                            if self.Config.stacktrace:
                                traceback.print_exc()

                try:
                    nice = p.nice()
                except (psutil.NoSuchProcess, ProcessLookupError):
                    continue
                except:
                    self.agent_log.verbose(
                        &#34;&#39;%s&#39; Process is not allowing us to get the nice option!&#34; % (name if name != &#34;&#34; else str(pid)))

                    if self.Config.stacktrace:
                        traceback.print_exc()

                try:
                    name = p.name()
                except (psutil.NoSuchProcess, ProcessLookupError):
                    continue
                except:
                    self.agent_log.verbose(
                        &#34;&#39;%s&#39; Process is not allowing us to get the name option!&#34; % (name if name != &#34;&#34; else str(pid)))

                    if self.Config.stacktrace:
                        traceback.print_exc()

                try:
                    username = p.username()
                except (psutil.NoSuchProcess, ProcessLookupError):
                    continue
                except:
                    self.agent_log.verbose(&#34;&#39;%s&#39; Process is not allowing us to get the username option!&#34; % (
                        name if name != &#34;&#34; else str(pid)))

                    if self.Config.stacktrace:
                        traceback.print_exc()

                try:
                    exe = p.exe()
                except (psutil.NoSuchProcess, ProcessLookupError):
                    continue
                except:
                    self.agent_log.verbose(
                        &#34;&#39;%s&#39; Process is not allowing us to get the exec option!&#34; % (name if name != &#34;&#34; else str(pid)))

                    if self.Config.stacktrace:
                        traceback.print_exc()

                try:
                    cmdline = p.cmdline()
                except (psutil.NoSuchProcess, ProcessLookupError):
                    continue
                except:
                    self.agent_log.verbose(&#34;&#39;%s&#39; Process is not allowing us to get the cmdline option!&#34; % (
                        name if name != &#34;&#34; else str(pid)))

                    if self.Config.stacktrace:
                        traceback.print_exc()

                try:
                    cpu_percent = p.cpu_percent(interval=None)
                except (psutil.NoSuchProcess, ProcessLookupError):
                    continue
                except:
                    self.agent_log.verbose(
                        &#34;&#39;%s&#39; Process is not allowing us to get the CPU usage!&#34; % (name if name != &#34;&#34; else str(pid)))

                    if self.Config.stacktrace:
                        traceback.print_exc()

                try:
                    memory_info = p.memory_info()._asdict()
                except (psutil.NoSuchProcess, ProcessLookupError):
                    continue
                except:
                    self.agent_log.verbose(&#34;&#39;%s&#39; Process is not allowing us to get memory usage information!&#34; % (
                        name if name != &#34;&#34; else str(pid)))

                    if self.Config.stacktrace:
                        traceback.print_exc()

                try:
                    memory_percent = p.memory_percent()
                except (psutil.NoSuchProcess, ProcessLookupError):
                    continue
                except:
                    self.agent_log.verbose(&#34;&#39;%s&#39; Process is not allowing us to get the percent of memory usage!&#34; % (
                        name if name != &#34;&#34; else str(pid)))

                    if self.Config.stacktrace:
                        traceback.print_exc()

                try:
                    num_fds = p.num_fds()
                except (psutil.NoSuchProcess, ProcessLookupError):
                    continue
                except:
                    self.agent_log.verbose(&#34;&#39;%s&#39; Process is not allowing us to get the num_fds option!&#34; % (
                        name if name != &#34;&#34; else str(pid)))

                    if self.Config.stacktrace:
                        traceback.print_exc()

                try:
                    io_counters = p.io_counters.__dict__
                except (psutil.NoSuchProcess, ProcessLookupError):
                    continue
                except:
                    self.agent_log.verbose(
                        &#34;&#39;%s&#39; Process is not allowing us to get the IO counters!&#34; % (name if name != &#34;&#34; else str(pid)))

                    if self.Config.stacktrace:
                        traceback.print_exc()

                try:
                    open_files = p.open_files()
                except (psutil.NoSuchProcess, ProcessLookupError):
                    continue
                except psutil.AccessDenied:
                    self.agent_log.verbose(&#34;&#39;%s&#39; Process is not allowing us to get the open_files option!&#34; % (
                        name if name != &#34;&#34; else str(pid)))

                    if self.Config.stacktrace:
                        traceback.print_exc()

                name = name[:1000]
                exe = exe[:1000]
                cmdline = cmdline[:1000]

                process = {
                    &#39;name&#39;: name,
                    &#39;exec&#39;: exe,
                    &#39;cmdline&#39;: cmdline,
                    &#39;pid&#39;: pid,
                    &#39;ppid&#39;: ppid,
                    &#39;children&#39;: children,
                    &#39;status&#39;: status,
                    &#39;username&#39;: username,
                    &#39;cpu_percent&#39;: cpu_percent,
                    &#39;memory&#39;: memory_info,
                    &#39;memory_percent&#39;: memory_percent,
                    &#39;num_fds&#39;: num_fds,
                    &#39;open_files&#39;: open_files,
                    &#39;io_counters&#39;: io_counters,
                    &#39;nice_level&#39;: nice
                }
                processes.append(process)
            except psutil.NoSuchProcess:
                continue
            except:
                self.agent_log.error(&#34;An error occured during process check!&#34;)

                if self.Config.stacktrace:
                    traceback.print_exc()

        windows_services = []
        windows_eventlog = {}
        if self.operating_system.isWindows() is True:
            if self.Config.config.getboolean(&#39;default&#39;, &#39;winservices&#39;):
                try:
                    for win_process in psutil.win_service_iter():
                        windows_services.append(win_process.as_dict())
                except:
                    self.agent_log.error(&#34;An error occured during windows services check!&#34;)

                    if self.Config.stacktrace:
                        traceback.print_exc()

            if self.Config.config.getboolean(&#39;default&#39;, &#39;wineventlog&#39;):
                try:
                    server = &#39;localhost&#39;  # name of the target computer to get event logs
                    logTypes = []
                    if self.Config.config.get(&#39;default&#39;, &#39;wineventlog-logtypes&#39;) != &#34;&#34;:
                        for logtype in self.Config.config.get(&#39;default&#39;, &#39;wineventlog-logtypes&#39;).split(&#39;,&#39;):
                            if logtype.strip() != &#39;&#39;:
                                logTypes.append(logtype.strip())
                    else:
                        logTypes = [&#39;System&#39;, &#39;Application&#39;, &#39;Security&#39;, &#39;openITCOCKPIT Agent&#39;]

                    evt_dict = {
                        win32con.EVENTLOG_AUDIT_FAILURE: &#39;EVENTLOG_AUDIT_FAILURE&#39;,  # 16 -&gt; critical
                        win32con.EVENTLOG_AUDIT_SUCCESS: &#39;EVENTLOG_AUDIT_SUCCESS&#39;,  # 8  -&gt; ok
                        win32con.EVENTLOG_INFORMATION_TYPE: &#39;EVENTLOG_INFORMATION_TYPE&#39;,  # 4  -&gt; ok
                        win32con.EVENTLOG_WARNING_TYPE: &#39;EVENTLOG_WARNING_TYPE&#39;,  # 2  -&gt; warning
                        win32con.EVENTLOG_ERROR_TYPE: &#39;EVENTLOG_ERROR_TYPE&#39;  # 1  -&gt; critical
                    }

                    for logType in logTypes:
                        try:
                            if logType not in windows_eventlog:
                                windows_eventlog[logType] = []
                            hand = win32evtlog.OpenEventLog(server, logType)
                            flags = win32evtlog.EVENTLOG_BACKWARDS_READ | win32evtlog.EVENTLOG_SEQUENTIAL_READ
                            total = win32evtlog.GetNumberOfEventLogRecords(hand)
                            events = win32evtlog.ReadEventLog(hand, flags, 0)
                            if events:
                                for event in events:
                                    msg = win32evtlogutil.SafeFormatMessage(event, logType)
                                    sidDesc = None
                                    if event.Sid is not None:
                                        try:
                                            domain, user, typ = win32security.LookupAccountSid(server, event.Sid)
                                            sidDesc = &#34;%s/%s&#34; % (domain, user)
                                        except win32security.error:
                                            sidDesc = str(event.Sid)

                                    evt_type = &#34;unknown&#34;
                                    if event.EventType in evt_dict.keys():
                                        evt_type = str(evt_dict[event.EventType])

                                    tmp_evt = {
                                        &#39;event_category&#39;: event.EventCategory,
                                        &#39;time_generated&#39;: str(event.TimeGenerated),
                                        &#39;source_name&#39;: event.SourceName,
                                        &#39;associated_user&#39;: sidDesc,
                                        &#39;event_id&#39;: event.EventID,
                                        &#39;event_type&#39;: evt_type,
                                        &#39;event_type_id&#39;: event.EventType,
                                        &#39;event_msg&#39;: msg,
                                        &#39;event_data&#39;: [data for data in
                                                       event.StringInserts] if event.StringInserts else &#39;&#39;
                                    }
                                    windows_eventlog[logType].append(tmp_evt)
                        except:
                            self.agent_log.error(
                                &#34;An error occured during windows eventlog check with log type %s!&#34; % (logType))

                            if self.Config.stacktrace:
                                traceback.print_exc()

                except:
                    self.agent_log.error(&#34;An error occured during windows eventlog check!&#34;)

                    if self.Config.stacktrace:
                        traceback.print_exc()

        try:
            agent = {
                &#39;last_updated&#39;: time.ctime(),
                &#39;last_updated_timestamp&#39;: round(time.time()),
                &#39;system&#39;: platform.system(),
                &#39;system_uptime&#39;: uptime,
                &#39;kernel_version&#39;: platform.release(),
                &#39;mac_version&#39;: platform.mac_ver()[0],
                &#39;agent_version&#39;: self.Config.agentVersion,
                &#39;temperature_unit&#39;: &#39;F&#39; if self.Config.temperatureIsFahrenheit else &#39;C&#39;
            }
        except:
            agent = {
                &#39;last_updated&#39;: time.ctime(),
                &#39;last_updated_timestamp&#39;: round(time.time()),
                &#39;system_uptime&#39;: uptime,
                &#39;agent_version&#39;: self.Config.agentVersion,
                &#39;temperature_unit&#39;: &#39;F&#39; if self.Config.temperatureIsFahrenheit else &#39;C&#39;
            }

        out = {
            &#39;agent&#39;: agent,
            # &#39;disks&#39;: disks,
            # &#39;disk_io&#39;: diskIO,
            # &#39;disk_io_total&#39;: diskIOTotal,
            # &#39;net_stats&#39;: net_stats,
            # &#39;net_io&#39;: netIO,

            # &#39;sensors&#39;: sensors,

            # &#39;cpu_total_percentage&#39;: cpuTotalPercentage,
            # &#39;cpu_percentage&#39;: cpuPercentage,
            # &#39;cpu_total_percentage_detailed&#39;: cpuTotalPercentageDetailed,
            # &#39;cpu_percentage_detailed&#39;: cpuPercentageDetailed,

            &#39;system_load&#39;: system_load_avg,
            &#39;users&#39;: users,

            &#39;memory&#39;: memory._asdict(),
            &#39;swap&#39;: swap._asdict(),

            # &#39;processes&#39;: processes
        }

        if self.Config.config.getboolean(&#39;default&#39;, &#39;diskstats&#39;):
            out[&#39;disks&#39;] = disks

        if self.Config.config.getboolean(&#39;default&#39;, &#39;diskio&#39;):
            out[&#39;disk_io&#39;] = diskIO

        if self.Config.config.getboolean(&#39;default&#39;, &#39;netstats&#39;):
            out[&#39;net_stats&#39;] = net_stats

        if self.Config.config.getboolean(&#39;default&#39;, &#39;netio&#39;):
            out[&#39;net_io&#39;] = netIO

        if self.Config.config.getboolean(&#39;default&#39;, &#39;sensorstats&#39;):
            out[&#39;sensors&#39;] = sensors

        if self.Config.config.getboolean(&#39;default&#39;, &#39;cpustats&#39;):
            out[&#39;cpu_total_percentage&#39;] = cpuTotalPercentage
            out[&#39;cpu_percentage&#39;] = cpuPercentage
            out[&#39;cpu_total_percentage_detailed&#39;] = cpuTotalPercentageDetailed
            out[&#39;cpu_percentage_detailed&#39;] = cpuPercentageDetailed

        if self.Config.config.getboolean(&#39;default&#39;, &#39;processstats&#39;):
            out[&#39;processes&#39;] = processes

        if self.operating_system.isWindows() is True:
            if self.Config.config.getboolean(&#39;default&#39;, &#39;winservices&#39;):
                out[&#39;windows_services&#39;] = windows_services
            if self.Config.config.getboolean(&#39;default&#39;, &#39;wineventlog&#39;):
                out[&#39;windows_eventlog&#39;] = windows_eventlog

        # if len(systemd_services_data) &gt; 0:
        #    out[&#39;systemd_services&#39;] = systemd_services_data
        #
        # if len(cached_customchecks_check_data) &gt; 0:
        #    out[&#39;customchecks&#39;] = cached_customchecks_check_data
        #
        # if len(docker_stats_data) &gt; 0:
        #    out[&#39;dockerstats&#39;] = docker_stats_data
        #
        # if len(qemu_stats_data) &gt; 0:
        #    out[&#39;qemustats&#39;] = qemu_stats_data
        #
        # if &#39;result&#39; in alfresco_stats_data and config[&#39;default&#39;][&#39;alfrescostats&#39;] in (1, &#34;1&#34;, &#34;true&#34;, &#34;True&#34;):
        #    out[&#39;alfrescostats&#39;] = alfresco_stats_data[&#39;result&#39;]

        # if jmx_import_successfull and &#39;alfrescostats&#39; in config[&#39;default&#39;] and config[&#39;default&#39;][&#39;alfrescostats&#39;] in (1, &#34;1&#34;, &#34;true&#34;, &#34;True&#34;, True):
        #    out[&#39;alfrescostats&#39;] = alfrescostats
        # if self.Config.verbose:
        #    print_lock.release()

        return out

    def wrapdiff(self, last, curr):
        &#34;&#34;&#34; Function to calculate the difference between last and curr

            If last &gt; curr, try to guess the boundary at which the value must have wrapped
            by trying the maximum values of 64, 32 and 16 bit signed and unsigned ints.
        &#34;&#34;&#34;

        if last &lt;= curr:
            return float(curr - last)

        boundary = None
        for chkbound in (64, 63, 32, 31, 16, 15):
            if last &gt; 2 ** chkbound:
                break
            boundary = chkbound
        if boundary is None:
            raise ArithmeticError(&#34;Couldn&#39;t determine boundary&#34;)
        return float(2 ** boundary - last + curr)

    @contextmanager
    def suppress_stdout_stderr(self):
        &#34;&#34;&#34;A context manager that redirects stdout and stderr to devnull&#34;&#34;&#34;
        with open(os.devnull, &#34;w&#34;) as devnull:
            old_stdout = sys.stdout
            sys.stdout = devnull
            try:
                yield
            finally:
                sys.stdout = old_stdout</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>src.checks.Check.Check</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="openitcockpit-agent.src.checks.default_checks.DefaultChecks.run_check"><code class="name flex">
<span>def <span class="ident">run_check</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Function to run the default checks</p>
<p>Run default checks to get following information points.</p>
<ul>
<li>disks (Storage devices with mountpoint, filesystem and storage space definitions)</li>
<li>disk_io (Read and write statistics of the storage devices)</li>
<li>net_io (Input and Outputstatistics of the network devices)</li>
<li>net_stats (Network devices including the possible speed, &hellip;)</li>
<li>sensors (Connected sensors, e.g. temperature of the cpu, akku state)</li>
<li>cpu_total_percentage (Used CPU calculation time in percent)</li>
<li>cpu_percentage (Used cpu calculation time in percent per core)</li>
<li>cpu_total_percentage_detailed (Cpu calculation time in percent per system ressource)</li>
<li>cpu_percentage_detailed (Cpu calculation time in percent per system ressource per core)</li>
<li>system_load (System load 1, 5, 15 as array)</li>
<li>users (Users logged on to the system, their terminals (pid), login time)</li>
<li>memory (Memory information, total, used, active, buffered, &hellip;)</li>
<li>swap (Swap information, total, used, &hellip;)</li>
<li>processes (Information to running processes, cpu, memory, pid, &hellip;)</li>
<li>agent (Agent version, last check time, system version, &hellip;)</li>
<li>dockerstats (Docker containers, id, cpu, memory, block io, pid)</li>
<li>qemustats (Information to active QEMU virtual machines)</li>
</ul>
<p>Notice:</p>
<p>Processes with id 0 or 1 are excluded of the process parent and child id check.
There are the root processes on linux, macOS and windows.
These checks are configurable: dockerstats, qemustats, cpustats, sensorstats, processstats, netstats, diskstats, netio, diskio, winservices.
Average values and iops in netio and diskio checks are available after the second check goes through.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Object (dictionary) containing all the default check results</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_check(self) -&gt; dict:
    &#34;&#34;&#34;Function to run the default checks

    Run default checks to get following information points.


    - disks (Storage devices with mountpoint, filesystem and storage space definitions)
    - disk_io (Read and write statistics of the storage devices)
    - net_io (Input and Outputstatistics of the network devices)
    - net_stats (Network devices including the possible speed, ...)
    - sensors (Connected sensors, e.g. temperature of the cpu, akku state)
    - cpu_total_percentage (Used CPU calculation time in percent)
    - cpu_percentage (Used cpu calculation time in percent per core)
    - cpu_total_percentage_detailed (Cpu calculation time in percent per system ressource)
    - cpu_percentage_detailed (Cpu calculation time in percent per system ressource per core)
    - system_load (System load 1, 5, 15 as array)
    - users (Users logged on to the system, their terminals (pid), login time)
    - memory (Memory information, total, used, active, buffered, ...)
    - swap (Swap information, total, used, ...)
    - processes (Information to running processes, cpu, memory, pid, ...)
    - agent (Agent version, last check time, system version, ...)
    - dockerstats (Docker containers, id, cpu, memory, block io, pid)
    - qemustats (Information to active QEMU virtual machines)


    Notice:

    Processes with id 0 or 1 are excluded of the process parent and child id check.
    There are the root processes on linux, macOS and windows.
    These checks are configurable: dockerstats, qemustats, cpustats, sensorstats, processstats, netstats, diskstats, netio, diskio, winservices.
    Average values and iops in netio and diskio checks are available after the second check goes through.


    Returns
    -------
    dict
        Object (dictionary) containing all the default check results

    &#34;&#34;&#34;
    self.agent_log.verbose(&#39;Running default checks&#39;)

    # if verbose:
    #    print_lock.acquire()

    if self.Config.config.getboolean(&#39;default&#39;, &#39;cpustats&#39;):
        # CPU #
        cpuTotalPercentage = psutil.cpu_percent()
        cpuPercentage = psutil.cpu_percent(interval=0, percpu=True)

        cpu = psutil.cpu_times_percent(interval=0, percpu=False)
        cpuTotalPercentageDetailed = cpu._asdict()

        cpuPercentageDetailed = [dict(cpu._asdict()) for cpu in
                                 psutil.cpu_times_percent(interval=0, percpu=True)]

    uptime = 0
    try:
        uptime = int(time.time() - psutil.boot_time())
    except:
        self.agent_log.error(&#34;Could not get system uptime!&#34;)

        if self.Config.stacktrace:
            traceback.print_exc()

    # totalCpus = psutil.cpu_count()
    # physicalCpus = psutil.cpu_count(logical=False)

    # cpuFrequency = psutil.cpu_freq()

    # MEMORY #

    memory = psutil.virtual_memory()
    swap = psutil.swap_memory()

    disks = []
    if self.Config.config.getboolean(&#39;default&#39;, &#39;diskstats&#39;):
        # DISKS #
        try:
            for disk in psutil.disk_partitions():
                if self.operating_system.isWindows():
                    if &#39;cdrom&#39; in disk.opts or disk.fstype == &#39;&#39;:
                        # skip cd-rom drives with no disk in it; they may raise
                        # ENOENT, pop-up a Windows GUI error for a non-ready
                        # partition or just hang.
                        continue
                disks.append(dict(
                    disk=disk._asdict(),
                    usage=psutil.disk_usage(disk.mountpoint)._asdict()
                ))
        except:
            self.agent_log.error(&#34;Could not get system disks!&#34;)

            if self.Config.stacktrace:
                traceback.print_exc()

    diskIO = None
    if hasattr(psutil, &#34;disk_io_counters&#34;) and self.Config.config.getboolean(&#39;default&#39;, &#39;diskio&#39;):
        try:
            # diskIOTotal = psutil.disk_io_counters(perdisk=False)._asdict()
            # diskIO = psutil.disk_io_counters(perdisk=True)
            diskIO = {disk: iops._asdict() for disk, iops in psutil.disk_io_counters(perdisk=True).items()}
            diskIO[&#39;timestamp&#39;] = time.time()

            for disk in diskIO:
                if disk != &#34;timestamp&#34; and disk in self.cached_diskIO:

                    diskIODiff = {}
                    diskIODiff[&#39;timestamp&#39;] = self.wrapdiff(float(self.cached_diskIO[&#39;timestamp&#39;]),
                                                            float(diskIO[&#39;timestamp&#39;]))

                    for attr in diskIO[disk]:
                        diff = self.wrapdiff(float(self.cached_diskIO[disk][attr]), float(diskIO[disk][attr]))
                        diskIODiff[attr] = diff

                    diskIO[disk][&#39;read_iops&#39;] = diskIODiff[&#39;read_count&#39;] / diskIODiff[&#39;timestamp&#39;]
                    diskIO[disk][&#39;write_iops&#39;] = diskIODiff[&#39;write_count&#39;] / diskIODiff[&#39;timestamp&#39;]

                    tot_ios = diskIODiff[&#39;read_count&#39;] + diskIODiff[&#39;write_count&#39;]
                    diskIO[disk][&#39;total_iops&#39;] = tot_ios / diskIODiff[&#39;timestamp&#39;]
                    # diskIO[disk][&#39;tot_ticks&#39;] = diskIODiff[&#39;busy_time&#39;]
                    # diskIO[disk][&#39;interval&#39;] = diskIODiff[&#39;timestamp&#39;]
                    if &#39;busy_time&#39; in diskIODiff:
                        diskIO[disk][&#39;load_percent&#39;] = diskIODiff[&#39;busy_time&#39;] / (
                                diskIODiff[&#39;timestamp&#39;] * 1000.) * 100.

                    if diskIODiff[&#39;read_count&#39;]:
                        diskIO[disk][&#39;read_avg_wait&#39;] = float(
                            diskIODiff[&#39;read_time&#39;] / diskIODiff[&#39;read_count&#39;])
                        diskIO[disk][&#39;read_avg_size&#39;] = float(
                            diskIODiff[&#39;read_bytes&#39;] / diskIODiff[&#39;read_count&#39;])
                    else:
                        diskIO[disk][&#39;read_avg_wait&#39;] = 0
                        diskIO[disk][&#39;read_avg_size&#39;] = 0

                    if diskIODiff[&#39;write_count&#39;]:
                        diskIO[disk][&#39;write_avg_wait&#39;] = float(
                            diskIODiff[&#39;write_time&#39;] / diskIODiff[&#39;write_count&#39;])
                        diskIO[disk][&#39;write_avg_size&#39;] = float(
                            diskIODiff[&#39;write_bytes&#39;] / diskIODiff[&#39;write_count&#39;])
                    else:
                        diskIO[disk][&#39;write_avg_wait&#39;] = 0
                        diskIO[disk][&#39;write_avg_size&#39;] = 0

                    if tot_ios:
                        diskIO[disk][&#39;total_avg_wait&#39;] = float(
                            (diskIODiff[&#39;read_time&#39;] + diskIODiff[&#39;write_time&#39;]) / tot_ios)
                    else:
                        diskIO[disk][&#39;total_avg_wait&#39;] = 0

            self.cached_diskIO = diskIO
        except:
            self.agent_log.error(&#34;Could not get disk io stats!&#34;)

            if self.Config.stacktrace:
                traceback.print_exc()

    netIO = None
    if hasattr(psutil, &#34;net_io_counters&#34;) and self.Config.config.getboolean(&#39;default&#39;, &#39;netio&#39;):
        try:
            netIO = {device: data._asdict() for device, data in psutil.net_io_counters(pernic=True).items()}
            netIO[&#39;timestamp&#39;] = time.time()

            for device in netIO:
                if device != &#34;timestamp&#34; and device in self.cached_netIO:

                    netIODiff = {}
                    netIODiff[&#39;timestamp&#39;] = self.wrapdiff(float(self.cached_netIO[&#39;timestamp&#39;]),
                                                           float(netIO[&#39;timestamp&#39;]))

                    for attr in netIO[device]:
                        diff = self.wrapdiff(float(self.cached_netIO[device][attr]), float(netIO[device][attr]))
                        netIODiff[attr] = diff

                    if netIODiff[&#39;bytes_sent&#39;]:
                        netIO[device][&#39;avg_bytes_sent_ps&#39;] = float(
                            netIODiff[&#39;bytes_sent&#39;] / netIODiff[&#39;timestamp&#39;])
                    else:
                        netIO[device][&#39;avg_bytes_sent_ps&#39;] = 0

                    if netIODiff[&#39;bytes_recv&#39;]:
                        netIO[device][&#39;avg_bytes_recv_ps&#39;] = float(
                            netIODiff[&#39;bytes_recv&#39;] / netIODiff[&#39;timestamp&#39;])
                    else:
                        netIO[device][&#39;avg_bytes_recv_ps&#39;] = 0

                    if netIODiff[&#39;packets_sent&#39;]:
                        netIO[device][&#39;avg_packets_sent_ps&#39;] = float(
                            netIODiff[&#39;packets_sent&#39;] / netIODiff[&#39;timestamp&#39;])
                    else:
                        netIO[device][&#39;avg_packets_sent_ps&#39;] = 0

                    if netIODiff[&#39;packets_recv&#39;]:
                        netIO[device][&#39;avg_packets_recv_ps&#39;] = float(
                            netIODiff[&#39;packets_recv&#39;] / netIODiff[&#39;timestamp&#39;])
                    else:
                        netIO[device][&#39;avg_packets_recv_ps&#39;] = 0

                    if netIODiff[&#39;errin&#39;]:
                        netIO[device][&#39;avg_errin&#39;] = float(netIODiff[&#39;errin&#39;] / netIODiff[&#39;timestamp&#39;])
                    else:
                        netIO[device][&#39;avg_errin&#39;] = 0

                    if netIODiff[&#39;errout&#39;]:
                        netIO[device][&#39;avg_errout&#39;] = float(netIODiff[&#39;errout&#39;] / netIODiff[&#39;timestamp&#39;])
                    else:
                        netIO[device][&#39;avg_errout&#39;] = 0

                    if netIODiff[&#39;dropin&#39;]:
                        netIO[device][&#39;avg_dropin&#39;] = float(netIODiff[&#39;dropin&#39;] / netIODiff[&#39;timestamp&#39;])
                    else:
                        netIO[device][&#39;avg_dropin&#39;] = 0

                    if netIODiff[&#39;dropout&#39;]:
                        netIO[device][&#39;avg_dropout&#39;] = float(netIODiff[&#39;dropout&#39;] / netIODiff[&#39;timestamp&#39;])
                    else:
                        netIO[device][&#39;avg_dropout&#39;] = 0

            self.cached_netIO = netIO
        except:
            self.agent_log.error(&#34;Could not get network io stats!&#34;)

            if self.Config.stacktrace:
                traceback.print_exc()

    net_stats = None
    if hasattr(psutil, &#34;net_if_stats&#34;) and self.Config.config.getboolean(&#39;default&#39;, &#39;netstats&#39;):
        try:
            net_stats = {device: data._asdict() for device, data in psutil.net_if_stats().items()}
        except:
            self.agent_log.error(&#34;Could not get network device stats!&#34;)

            if self.Config.stacktrace:
                traceback.print_exc()

    sensors = {}
    if self.Config.config.getboolean(&#39;default&#39;, &#39;sensorstats&#39;):
        try:
            if hasattr(psutil, &#34;sensors_temperatures&#34;) and self.operating_system.isWindows() is False:
                sensors[&#39;temperatures&#39;] = {}
                for device, data in psutil.sensors_temperatures(
                        fahrenheit=self.Config.temperatureIsFahrenheit).items():
                    sensors[&#39;temperatures&#39;][device] = []
                    for value in data:
                        sensors[&#39;temperatures&#39;][device].append(value._asdict())
            else:
                sensors[&#39;temperatures&#39;] = {}
        except:
            self.agent_log.error(&#34;Could not get temperature sensor data!&#34;)

            if self.Config.stacktrace:
                traceback.print_exc()

        try:
            if hasattr(psutil, &#34;sensors_fans&#34;) and self.operating_system.isWindows() is False:
                sensors[&#39;fans&#39;] = {}
                for device, data in psutil.sensors_fans().items():
                    sensors[&#39;fans&#39;][device] = []
                    for value in data:
                        sensors[&#39;fans&#39;][device].append(value._asdict())
            else:
                sensors[&#39;fans&#39;] = {}
        except:
            self.agent_log.error(&#34;Could not get fans sensor data!&#34;)

            if self.Config.stacktrace:
                traceback.print_exc()

        try:
            if hasattr(psutil, &#34;sensors_battery&#34;):
                sensors_battery = psutil.sensors_battery()
                if sensors_battery is not None:
                    sensors[&#39;battery&#39;] = sensors_battery._asdict()
                else:
                    sensors[&#39;battery&#39;] = {}
            else:
                sensors[&#39;battery&#39;] = {}
        except:
            self.agent_log.error(&#34;Could not get battery sensor data!&#34;)

            if self.Config.stacktrace:
                traceback.print_exc()

    pids = psutil.pids()

    system_load_avg = []
    try:
        if hasattr(psutil, &#34;getloadavg&#34;):
            system_load_avg = psutil.getloadavg()
        elif hasattr(os, &#34;getloadavg&#34;):
            system_load_avg = os.getloadavg()
    except:
        self.agent_log.error(&#34;Could not get average system load!&#34;)

        if self.Config.stacktrace:
            traceback.print_exc()

    users = []
    try:
        if hasattr(psutil, &#34;users&#34;):
            users = [user._asdict() for user in psutil.users()]
    except:
        self.agent_log.error(&#34;Could not get users, connected to the system!&#34;)

        if self.Config.stacktrace:
            traceback.print_exc()

    # processes = [ psutil.Process(pid).as_dict() for pid in pids ]
    processes = []

    tmpProcessList = []

    if self.Config.config.getboolean(&#39;default&#39;, &#39;processstats&#39;):
        for pid in pids:
            try:
                p = psutil.Process(pid)
                try:
                    cpu_percent = p.cpu_percent(interval=None)

                    tmpProcessList.append(p)
                except:
                    self.agent_log.verbose(&#34;&#39;%s&#39; Process is not allowing us to get the CPU usage!&#34; % str(pid))

                    if self.Config.stacktrace:
                        traceback.print_exc()


            except psutil.NoSuchProcess:
                continue
            except:
                self.agent_log.error(&#34;An error occured during process check!&#34;)

                if self.Config.stacktrace:
                    traceback.print_exc()

    for p in tmpProcessList:
        try:

            pid = p.pid
            ppid = None
            status = &#34;&#34;
            username = &#34;&#34;
            nice = None
            name = &#34;&#34;
            exe = &#34;&#34;
            cmdline = &#34;&#34;
            cpu_percent = None
            memory_info = {}
            memory_percent = None
            num_fds = {}
            io_counters = {}
            open_files = &#34;&#34;
            children = []

            if pid not in (1, 2):
                try:
                    if callable(p.parent):
                        ppid = p.parent().pid
                except (psutil.NoSuchProcess, ProcessLookupError):
                    continue
                except AttributeError:
                    self.agent_log.verbose(
                        &#34;&#39;%s&#39; Process is not allowing us to get the parent process id!&#34; % (str(pid)))

                    if self.Config.stacktrace:
                        traceback.print_exc()

                if self.Config.config.getboolean(&#39;default&#39;, &#39;processstats-including-child-ids&#39;):
                    try:
                        if callable(p.children):
                            with self.suppress_stdout_stderr():
                                for child in p.children(recursive=True):
                                    children.append(child.pid)
                    except:
                        self.agent_log.verbose(
                            &#34;&#39;%s&#39; Process is not allowing us to get the child process ids!&#34; % (str(pid)))

                        if self.Config.stacktrace:
                            traceback.print_exc()

            try:
                nice = p.nice()
            except (psutil.NoSuchProcess, ProcessLookupError):
                continue
            except:
                self.agent_log.verbose(
                    &#34;&#39;%s&#39; Process is not allowing us to get the nice option!&#34; % (name if name != &#34;&#34; else str(pid)))

                if self.Config.stacktrace:
                    traceback.print_exc()

            try:
                name = p.name()
            except (psutil.NoSuchProcess, ProcessLookupError):
                continue
            except:
                self.agent_log.verbose(
                    &#34;&#39;%s&#39; Process is not allowing us to get the name option!&#34; % (name if name != &#34;&#34; else str(pid)))

                if self.Config.stacktrace:
                    traceback.print_exc()

            try:
                username = p.username()
            except (psutil.NoSuchProcess, ProcessLookupError):
                continue
            except:
                self.agent_log.verbose(&#34;&#39;%s&#39; Process is not allowing us to get the username option!&#34; % (
                    name if name != &#34;&#34; else str(pid)))

                if self.Config.stacktrace:
                    traceback.print_exc()

            try:
                exe = p.exe()
            except (psutil.NoSuchProcess, ProcessLookupError):
                continue
            except:
                self.agent_log.verbose(
                    &#34;&#39;%s&#39; Process is not allowing us to get the exec option!&#34; % (name if name != &#34;&#34; else str(pid)))

                if self.Config.stacktrace:
                    traceback.print_exc()

            try:
                cmdline = p.cmdline()
            except (psutil.NoSuchProcess, ProcessLookupError):
                continue
            except:
                self.agent_log.verbose(&#34;&#39;%s&#39; Process is not allowing us to get the cmdline option!&#34; % (
                    name if name != &#34;&#34; else str(pid)))

                if self.Config.stacktrace:
                    traceback.print_exc()

            try:
                cpu_percent = p.cpu_percent(interval=None)
            except (psutil.NoSuchProcess, ProcessLookupError):
                continue
            except:
                self.agent_log.verbose(
                    &#34;&#39;%s&#39; Process is not allowing us to get the CPU usage!&#34; % (name if name != &#34;&#34; else str(pid)))

                if self.Config.stacktrace:
                    traceback.print_exc()

            try:
                memory_info = p.memory_info()._asdict()
            except (psutil.NoSuchProcess, ProcessLookupError):
                continue
            except:
                self.agent_log.verbose(&#34;&#39;%s&#39; Process is not allowing us to get memory usage information!&#34; % (
                    name if name != &#34;&#34; else str(pid)))

                if self.Config.stacktrace:
                    traceback.print_exc()

            try:
                memory_percent = p.memory_percent()
            except (psutil.NoSuchProcess, ProcessLookupError):
                continue
            except:
                self.agent_log.verbose(&#34;&#39;%s&#39; Process is not allowing us to get the percent of memory usage!&#34; % (
                    name if name != &#34;&#34; else str(pid)))

                if self.Config.stacktrace:
                    traceback.print_exc()

            try:
                num_fds = p.num_fds()
            except (psutil.NoSuchProcess, ProcessLookupError):
                continue
            except:
                self.agent_log.verbose(&#34;&#39;%s&#39; Process is not allowing us to get the num_fds option!&#34; % (
                    name if name != &#34;&#34; else str(pid)))

                if self.Config.stacktrace:
                    traceback.print_exc()

            try:
                io_counters = p.io_counters.__dict__
            except (psutil.NoSuchProcess, ProcessLookupError):
                continue
            except:
                self.agent_log.verbose(
                    &#34;&#39;%s&#39; Process is not allowing us to get the IO counters!&#34; % (name if name != &#34;&#34; else str(pid)))

                if self.Config.stacktrace:
                    traceback.print_exc()

            try:
                open_files = p.open_files()
            except (psutil.NoSuchProcess, ProcessLookupError):
                continue
            except psutil.AccessDenied:
                self.agent_log.verbose(&#34;&#39;%s&#39; Process is not allowing us to get the open_files option!&#34; % (
                    name if name != &#34;&#34; else str(pid)))

                if self.Config.stacktrace:
                    traceback.print_exc()

            name = name[:1000]
            exe = exe[:1000]
            cmdline = cmdline[:1000]

            process = {
                &#39;name&#39;: name,
                &#39;exec&#39;: exe,
                &#39;cmdline&#39;: cmdline,
                &#39;pid&#39;: pid,
                &#39;ppid&#39;: ppid,
                &#39;children&#39;: children,
                &#39;status&#39;: status,
                &#39;username&#39;: username,
                &#39;cpu_percent&#39;: cpu_percent,
                &#39;memory&#39;: memory_info,
                &#39;memory_percent&#39;: memory_percent,
                &#39;num_fds&#39;: num_fds,
                &#39;open_files&#39;: open_files,
                &#39;io_counters&#39;: io_counters,
                &#39;nice_level&#39;: nice
            }
            processes.append(process)
        except psutil.NoSuchProcess:
            continue
        except:
            self.agent_log.error(&#34;An error occured during process check!&#34;)

            if self.Config.stacktrace:
                traceback.print_exc()

    windows_services = []
    windows_eventlog = {}
    if self.operating_system.isWindows() is True:
        if self.Config.config.getboolean(&#39;default&#39;, &#39;winservices&#39;):
            try:
                for win_process in psutil.win_service_iter():
                    windows_services.append(win_process.as_dict())
            except:
                self.agent_log.error(&#34;An error occured during windows services check!&#34;)

                if self.Config.stacktrace:
                    traceback.print_exc()

        if self.Config.config.getboolean(&#39;default&#39;, &#39;wineventlog&#39;):
            try:
                server = &#39;localhost&#39;  # name of the target computer to get event logs
                logTypes = []
                if self.Config.config.get(&#39;default&#39;, &#39;wineventlog-logtypes&#39;) != &#34;&#34;:
                    for logtype in self.Config.config.get(&#39;default&#39;, &#39;wineventlog-logtypes&#39;).split(&#39;,&#39;):
                        if logtype.strip() != &#39;&#39;:
                            logTypes.append(logtype.strip())
                else:
                    logTypes = [&#39;System&#39;, &#39;Application&#39;, &#39;Security&#39;, &#39;openITCOCKPIT Agent&#39;]

                evt_dict = {
                    win32con.EVENTLOG_AUDIT_FAILURE: &#39;EVENTLOG_AUDIT_FAILURE&#39;,  # 16 -&gt; critical
                    win32con.EVENTLOG_AUDIT_SUCCESS: &#39;EVENTLOG_AUDIT_SUCCESS&#39;,  # 8  -&gt; ok
                    win32con.EVENTLOG_INFORMATION_TYPE: &#39;EVENTLOG_INFORMATION_TYPE&#39;,  # 4  -&gt; ok
                    win32con.EVENTLOG_WARNING_TYPE: &#39;EVENTLOG_WARNING_TYPE&#39;,  # 2  -&gt; warning
                    win32con.EVENTLOG_ERROR_TYPE: &#39;EVENTLOG_ERROR_TYPE&#39;  # 1  -&gt; critical
                }

                for logType in logTypes:
                    try:
                        if logType not in windows_eventlog:
                            windows_eventlog[logType] = []
                        hand = win32evtlog.OpenEventLog(server, logType)
                        flags = win32evtlog.EVENTLOG_BACKWARDS_READ | win32evtlog.EVENTLOG_SEQUENTIAL_READ
                        total = win32evtlog.GetNumberOfEventLogRecords(hand)
                        events = win32evtlog.ReadEventLog(hand, flags, 0)
                        if events:
                            for event in events:
                                msg = win32evtlogutil.SafeFormatMessage(event, logType)
                                sidDesc = None
                                if event.Sid is not None:
                                    try:
                                        domain, user, typ = win32security.LookupAccountSid(server, event.Sid)
                                        sidDesc = &#34;%s/%s&#34; % (domain, user)
                                    except win32security.error:
                                        sidDesc = str(event.Sid)

                                evt_type = &#34;unknown&#34;
                                if event.EventType in evt_dict.keys():
                                    evt_type = str(evt_dict[event.EventType])

                                tmp_evt = {
                                    &#39;event_category&#39;: event.EventCategory,
                                    &#39;time_generated&#39;: str(event.TimeGenerated),
                                    &#39;source_name&#39;: event.SourceName,
                                    &#39;associated_user&#39;: sidDesc,
                                    &#39;event_id&#39;: event.EventID,
                                    &#39;event_type&#39;: evt_type,
                                    &#39;event_type_id&#39;: event.EventType,
                                    &#39;event_msg&#39;: msg,
                                    &#39;event_data&#39;: [data for data in
                                                   event.StringInserts] if event.StringInserts else &#39;&#39;
                                }
                                windows_eventlog[logType].append(tmp_evt)
                    except:
                        self.agent_log.error(
                            &#34;An error occured during windows eventlog check with log type %s!&#34; % (logType))

                        if self.Config.stacktrace:
                            traceback.print_exc()

            except:
                self.agent_log.error(&#34;An error occured during windows eventlog check!&#34;)

                if self.Config.stacktrace:
                    traceback.print_exc()

    try:
        agent = {
            &#39;last_updated&#39;: time.ctime(),
            &#39;last_updated_timestamp&#39;: round(time.time()),
            &#39;system&#39;: platform.system(),
            &#39;system_uptime&#39;: uptime,
            &#39;kernel_version&#39;: platform.release(),
            &#39;mac_version&#39;: platform.mac_ver()[0],
            &#39;agent_version&#39;: self.Config.agentVersion,
            &#39;temperature_unit&#39;: &#39;F&#39; if self.Config.temperatureIsFahrenheit else &#39;C&#39;
        }
    except:
        agent = {
            &#39;last_updated&#39;: time.ctime(),
            &#39;last_updated_timestamp&#39;: round(time.time()),
            &#39;system_uptime&#39;: uptime,
            &#39;agent_version&#39;: self.Config.agentVersion,
            &#39;temperature_unit&#39;: &#39;F&#39; if self.Config.temperatureIsFahrenheit else &#39;C&#39;
        }

    out = {
        &#39;agent&#39;: agent,
        # &#39;disks&#39;: disks,
        # &#39;disk_io&#39;: diskIO,
        # &#39;disk_io_total&#39;: diskIOTotal,
        # &#39;net_stats&#39;: net_stats,
        # &#39;net_io&#39;: netIO,

        # &#39;sensors&#39;: sensors,

        # &#39;cpu_total_percentage&#39;: cpuTotalPercentage,
        # &#39;cpu_percentage&#39;: cpuPercentage,
        # &#39;cpu_total_percentage_detailed&#39;: cpuTotalPercentageDetailed,
        # &#39;cpu_percentage_detailed&#39;: cpuPercentageDetailed,

        &#39;system_load&#39;: system_load_avg,
        &#39;users&#39;: users,

        &#39;memory&#39;: memory._asdict(),
        &#39;swap&#39;: swap._asdict(),

        # &#39;processes&#39;: processes
    }

    if self.Config.config.getboolean(&#39;default&#39;, &#39;diskstats&#39;):
        out[&#39;disks&#39;] = disks

    if self.Config.config.getboolean(&#39;default&#39;, &#39;diskio&#39;):
        out[&#39;disk_io&#39;] = diskIO

    if self.Config.config.getboolean(&#39;default&#39;, &#39;netstats&#39;):
        out[&#39;net_stats&#39;] = net_stats

    if self.Config.config.getboolean(&#39;default&#39;, &#39;netio&#39;):
        out[&#39;net_io&#39;] = netIO

    if self.Config.config.getboolean(&#39;default&#39;, &#39;sensorstats&#39;):
        out[&#39;sensors&#39;] = sensors

    if self.Config.config.getboolean(&#39;default&#39;, &#39;cpustats&#39;):
        out[&#39;cpu_total_percentage&#39;] = cpuTotalPercentage
        out[&#39;cpu_percentage&#39;] = cpuPercentage
        out[&#39;cpu_total_percentage_detailed&#39;] = cpuTotalPercentageDetailed
        out[&#39;cpu_percentage_detailed&#39;] = cpuPercentageDetailed

    if self.Config.config.getboolean(&#39;default&#39;, &#39;processstats&#39;):
        out[&#39;processes&#39;] = processes

    if self.operating_system.isWindows() is True:
        if self.Config.config.getboolean(&#39;default&#39;, &#39;winservices&#39;):
            out[&#39;windows_services&#39;] = windows_services
        if self.Config.config.getboolean(&#39;default&#39;, &#39;wineventlog&#39;):
            out[&#39;windows_eventlog&#39;] = windows_eventlog

    # if len(systemd_services_data) &gt; 0:
    #    out[&#39;systemd_services&#39;] = systemd_services_data
    #
    # if len(cached_customchecks_check_data) &gt; 0:
    #    out[&#39;customchecks&#39;] = cached_customchecks_check_data
    #
    # if len(docker_stats_data) &gt; 0:
    #    out[&#39;dockerstats&#39;] = docker_stats_data
    #
    # if len(qemu_stats_data) &gt; 0:
    #    out[&#39;qemustats&#39;] = qemu_stats_data
    #
    # if &#39;result&#39; in alfresco_stats_data and config[&#39;default&#39;][&#39;alfrescostats&#39;] in (1, &#34;1&#34;, &#34;true&#34;, &#34;True&#34;):
    #    out[&#39;alfrescostats&#39;] = alfresco_stats_data[&#39;result&#39;]

    # if jmx_import_successfull and &#39;alfrescostats&#39; in config[&#39;default&#39;] and config[&#39;default&#39;][&#39;alfrescostats&#39;] in (1, &#34;1&#34;, &#34;true&#34;, &#34;True&#34;, True):
    #    out[&#39;alfrescostats&#39;] = alfrescostats
    # if self.Config.verbose:
    #    print_lock.release()

    return out</code></pre>
</details>
</dd>
<dt id="openitcockpit-agent.src.checks.default_checks.DefaultChecks.suppress_stdout_stderr"><code class="name flex">
<span>def <span class="ident">suppress_stdout_stderr</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>A context manager that redirects stdout and stderr to devnull</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@contextmanager
def suppress_stdout_stderr(self):
    &#34;&#34;&#34;A context manager that redirects stdout and stderr to devnull&#34;&#34;&#34;
    with open(os.devnull, &#34;w&#34;) as devnull:
        old_stdout = sys.stdout
        sys.stdout = devnull
        try:
            yield
        finally:
            sys.stdout = old_stdout</code></pre>
</details>
</dd>
<dt id="openitcockpit-agent.src.checks.default_checks.DefaultChecks.wrapdiff"><code class="name flex">
<span>def <span class="ident">wrapdiff</span></span>(<span>self, last, curr)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to calculate the difference between last and curr</p>
<p>If last &gt; curr, try to guess the boundary at which the value must have wrapped
by trying the maximum values of 64, 32 and 16 bit signed and unsigned ints.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapdiff(self, last, curr):
    &#34;&#34;&#34; Function to calculate the difference between last and curr

        If last &gt; curr, try to guess the boundary at which the value must have wrapped
        by trying the maximum values of 64, 32 and 16 bit signed and unsigned ints.
    &#34;&#34;&#34;

    if last &lt;= curr:
        return float(curr - last)

    boundary = None
    for chkbound in (64, 63, 32, 31, 16, 15):
        if last &gt; 2 ** chkbound:
            break
        boundary = chkbound
    if boundary is None:
        raise ArithmeticError(&#34;Couldn&#39;t determine boundary&#34;)
    return float(2 ** boundary - last + curr)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="openitcockpit-agent.src.checks" href="index.html">openitcockpit-agent.src.checks</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="openitcockpit-agent.src.checks.default_checks.DefaultChecks" href="#openitcockpit-agent.src.checks.default_checks.DefaultChecks">DefaultChecks</a></code></h4>
<ul class="">
<li><code><a title="openitcockpit-agent.src.checks.default_checks.DefaultChecks.run_check" href="#openitcockpit-agent.src.checks.default_checks.DefaultChecks.run_check">run_check</a></code></li>
<li><code><a title="openitcockpit-agent.src.checks.default_checks.DefaultChecks.suppress_stdout_stderr" href="#openitcockpit-agent.src.checks.default_checks.DefaultChecks.suppress_stdout_stderr">suppress_stdout_stderr</a></code></li>
<li><code><a title="openitcockpit-agent.src.checks.default_checks.DefaultChecks.wrapdiff" href="#openitcockpit-agent.src.checks.default_checks.DefaultChecks.wrapdiff">wrapdiff</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>