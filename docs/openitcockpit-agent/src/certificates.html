<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>openitcockpit-agent.src.certificates API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>openitcockpit-agent.src.certificates</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import datetime
import errno
import json
import os
import traceback
from threading import Lock

import OpenSSL
import ssl
import hashlib
import urllib3
import requests
from Crypto.Hash import SHA512

from src.config import Config
from src.agent_log import AgentLog
from src.filesystem import Filesystem
from src.exceptions.untrusted_agent_exception import UntrustedAgentException

from OpenSSL.SSL import FILETYPE_PEM
from OpenSSL.crypto import (dump_certificate_request, dump_privatekey, load_certificate, PKey, TYPE_RSA, X509Req)


class Certificates:
    RENEWAL_SUCESSFUL = 1
    UNTRUSTED_AGENT = 2
    RENEWAL_ERROR = 3

    def __init__(self, config, agent_log):
        self.Config: Config = config
        self.agent_log: AgentLog = agent_log

        self.days_until_cert_warning = 120
        self.days_until_ca_warning = 30

        self.cert_checksum = None
        self.certificate_check_lock = Lock()
        self.checksum_lock = Lock()

    def get_csr(self) -&gt; FILETYPE_PEM:
        &#34;&#34;&#34;Function that creates a new Certificate signing request (CSR)

        Creates a RSA (4096) certificate request.
        The hostname is config[&#39;oitc&#39;][&#39;hostuuid&#39;] + &#39;.agent.oitc&#39;.

        Writes csr in the default or custom autossl-csr-file.

        Writes certificate key in the default or custom autossl-key-file.


        Returns
        -------
        FILETYPE_PEM
            Returns a pem object (FILETYPE_PEM) on success

        &#34;&#34;&#34;

        try:

            # ECC (not working yet)
            #
            # from Crypto.PublicKey import ECC
            #
            # key = ECC.generate(curve=&#39;prime256v1&#39;)
            # req = X509Req()
            # req.get_subject().CN = config[&#39;oitc&#39;][&#39;hostuuid&#39;]+&#39;.agent.oitc&#39;
            # publicKey = key.public_key().export_key(format=&#39;PEM&#39;, compress=False)
            # privateKey = key.export_key(format=&#39;PEM&#39;, compress=False, use_pkcs8=True)
            #
            # pubdict = {}
            # pubdict[&#39;_only_public&#39;] = publicKey
            # req.sign(publicKey, &#39;sha384&#39;)

            self.agent_log.info(&#39;Creating new Certificate Signing Request (CSR)&#39;)

            # create public/private key
            key = PKey()
            key.generate_key(TYPE_RSA, 4096)

            # Generate CSR
            req = X509Req()
            req.get_subject().CN = self.Config.config.get(&#39;oitc&#39;, &#39;hostuuid&#39;) + &#39;.agent.oitc&#39;

            # Experimental; not supported by php agent csr sign method yet
            san_list = [&#34;DNS:localhost&#34;, &#34;DNS:127.0.0.1&#34;]
            req.add_extensions([
                OpenSSL.crypto.X509Extension(b&#34;subjectAltName&#34;, True, (&#34;, &#34;.join(san_list)).encode(&#39;ascii&#39;))
            ])

            # req.get_subject().O = &#39;XYZ Widgets Inc&#39;
            # req.get_subject().OU = &#39;IT Department&#39;
            # req.get_subject().L = &#39;Seattle&#39;
            # req.get_subject().ST = &#39;Washington&#39;
            # req.get_subject().C = &#39;US&#39;
            # req.get_subject().emailAddress = &#39;e@example.com&#39;
            req.set_pubkey(key)

            # b&#39;sha512&#39; will throw an error so we pass a string even if the function docs says it wants a byte string
            req.sign(key, &#39;sha512&#39;)

            ssl_paths = [
                self.Config.config[&#39;default&#39;][&#39;autossl-csr-file&#39;],
                self.Config.config[&#39;default&#39;][&#39;autossl-key-file&#39;],
                self.Config.config[&#39;default&#39;][&#39;autossl-crt-file&#39;],
                self.Config.config[&#39;default&#39;][&#39;autossl-ca-file&#39;]
            ]

            for filename in ssl_paths:
                if not os.path.exists(os.path.dirname(filename)):
                    try:
                        os.makedirs(os.path.dirname(filename))
                    except OSError as exc:  # Guard against race condition
                        if exc.errno != errno.EEXIST:
                            self.agent_log.error(&#39;An error occurred while creating the ssl files containing folders&#39;)
                            if self.Config.stacktrace:
                                raise

            csr = dump_certificate_request(FILETYPE_PEM, req)
            with open(self.Config.config[&#39;default&#39;][&#39;autossl-csr-file&#39;], &#39;wb+&#39;) as f:
                f.write(csr)
            with open(self.Config.config[&#39;default&#39;][&#39;autossl-key-file&#39;], &#39;wb+&#39;) as f:
                f.write(dump_privatekey(FILETYPE_PEM, key))

            self.agent_log.info(&#39;CSR file written&#39;)

            return csr
        except:
            self.agent_log.error(&#39;An error occurred while creating a new Certificate Signing Request (CSR)&#39;)
            traceback.print_exc()

            if self.Config.stacktrace:
                traceback.print_exc()

            return False

    def requires_new_certificate(self) -&gt; bool:
        &#34;&#34;&#34;Checks if new autossl certificates are required if:
         - no agent certificate exists
        &#34;&#34;&#34;

        if self.Config.autossl is False:
            return False

        # Check if agent certificate file exists
        if not Filesystem.file_readable(self.Config.config[&#39;default&#39;][&#39;autossl-crt-file&#39;]):
            self.agent_log.warning(
                &#39;Could not read agent certificate file %s&#39; % self.Config.config[&#39;default&#39;][&#39;autossl-crt-file&#39;]
            )
            return True

        # Check if CA certificate file exists
        if not Filesystem.file_readable(self.Config.config[&#39;default&#39;][&#39;autossl-ca-file&#39;]):
            self.agent_log.warning(
                &#39;Could not read CA certificate file %s&#39; % self.Config.config[&#39;default&#39;][&#39;autossl-ca-file&#39;]
            )
            return True

        return False

    def requires_certificate_renewal(self) -&gt; bool:
        &#34;&#34;&#34;Checks if a autossl certificates requires a renewal:
         - agent certificate expire soon
         - CA certificate expires soon
        &#34;&#34;&#34;

        # Check if agent certificate will expire soon
        with open(self.Config.config[&#39;default&#39;][&#39;autossl-crt-file&#39;], &#39;rb&#39;) as f:
            cert = f.read()
            x509 = load_certificate(FILETYPE_PEM, cert)
            x509info = x509.get_notAfter()
            exp_day = x509info[6:8].decode(&#39;utf-8&#39;)
            exp_month = x509info[4:6].decode(&#39;utf-8&#39;)
            exp_year = x509info[:4].decode(&#39;utf-8&#39;)
            exp_date = str(exp_day) + &#34;-&#34; + str(exp_month) + &#34;-&#34; + str(exp_year)

            self.agent_log.info(&#34;SSL Certificate expires in %s on %s (DD-MM-YYYY)&#34; % (
                str(datetime.date(int(exp_year),
                                  int(exp_month),
                                  int(exp_day)) - datetime.datetime.now().date()).split(&#39;,&#39;)[0], exp_date
            ))

            if datetime.date(int(exp_year), int(exp_month),
                             int(exp_day)) - datetime.datetime.now().date() &lt;= datetime.timedelta(
                self.days_until_cert_warning):
                self.agent_log.warning(
                    &#39;Agent SSL certificate will expire soon. Try to create a new one automatically ...&#39;)
                return True

        # Check if CA certificate will expire soon
        if Filesystem.file_readable(self.Config.config[&#39;default&#39;][&#39;autossl-ca-file&#39;]):
            self.agent_log.info(&#39;CA file %s found and readable&#39; % self.Config.config[&#39;default&#39;][&#39;autossl-ca-file&#39;])
            with open(self.Config.config[&#39;default&#39;][&#39;autossl-ca-file&#39;], &#39;rb&#39;) as f:
                ca = f.read()
                x509 = load_certificate(FILETYPE_PEM, ca)
                x509info = x509.get_notAfter()
                exp_day = x509info[6:8].decode(&#39;utf-8&#39;)
                exp_month = x509info[4:6].decode(&#39;utf-8&#39;)
                exp_year = x509info[:4].decode(&#39;utf-8&#39;)
                exp_date = str(exp_day) + &#34;-&#34; + str(exp_month) + &#34;-&#34; + str(exp_year)

                if datetime.date(int(exp_year), int(exp_month),
                                 int(exp_day)) - datetime.datetime.now().date() &lt;= datetime.timedelta(
                    self.days_until_ca_warning):
                    self.agent_log.warning(&#34;CA Certificate expires in %s on %s (DD-MM-YYYY)&#34; % (
                        str(datetime.date(int(exp_year), int(exp_month),
                                          int(exp_day)) - datetime.datetime.now().date()).split(
                            &#39;,&#39;)[0], exp_date))
                    return True

        return False

    def check_auto_certificate(self) -&gt; bool:
        &#34;&#34;&#34;Function to check the automatically generated certificate

        This function checks if the automatically generated certificate is installed and will otherwise trigger the download.
        In addition it checks if the certificate will expire soon.

        &#34;&#34;&#34;

        self.agent_log.info(&#39;Checking auto TLS certificate&#39;)

        trigger_reload = False
        if self.requires_new_certificate() is True:
            result = self._pull_crt_from_server(renew=False)
            if result == self.RENEWAL_SUCESSFUL:
                trigger_reload = True

            if result == self.UNTRUSTED_AGENT:
                # throw the UntrustedAgentException to the function the calls check_auto_certificate
                # so it can set the certificate check interval to 60 seconds instead of 6 hours
                raise UntrustedAgentException

        if Filesystem.file_readable(self.Config.config[&#39;default&#39;][&#39;autossl-crt-file&#39;]):
            if self.requires_certificate_renewal() is True:
                result = self._pull_crt_from_server(renew=True)
                if result == self.RENEWAL_SUCESSFUL:
                    trigger_reload = True

                if result == self.UNTRUSTED_AGENT:
                    # throw the UntrustedAgentException to the function the calls check_auto_certificate
                    # so it can set the certificate check interval to 60 seconds instead of 6 hours
                    raise UntrustedAgentException

        return trigger_reload

    def _pull_crt_from_server(self, renew=False) -&gt; int:
        &#34;&#34;&#34;Function to pull a new certificate using a Certificate signing request (CSR)

        This function tries to pull a new certificate from the configured openITCOCKPIT Server.
        Therefore a new certificate signing request (CSR) is needed and self.get_csr() will be called.
        The request with the CSR should return the new client and CA certificate.

        If the agent is not yet trusted by the openITCOCKPIT Server a manual confirmation in the openITCOCKPIT frontend is needed!

        If an existing certificate expired, a sha512 checksum has to be sent with the request to the openITCOCKPIT Server.
        With that checksum the server can validate, that the request was sent from a trusted agent (that has access to the old certificate).

        Returns
        -------
        int
        1 = successful =&gt; self.RENEWAL_SUCESSFUL
        2 = untrusted agent =&gt; self.UNTRUSTED_AGENT
        3 = other error =&gt; self.RENEWAL_ERROR
        &#34;&#34;&#34;

        # ONLY PULL cert if Agent is running in PUSH mode!!
        if self.Config.is_push_mode is False:
            return self.RENEWAL_ERROR

        if self.certificate_check_lock.locked():
            self.agent_log.error(&#39;Function to pull a new certificate is locked by another thread!&#39;)
            return self.RENEWAL_ERROR

        # with self.certificate_check_lock is a shortcut for:
        # self.certificate_check_lock.acquire()
        # do_something()
        # self.certificate_check_lock.release()
        with self.certificate_check_lock:
            self.agent_log.info(&#39;Pulling Certificate Signing Request (CSR) file from Server&#39;)

            try:
                csr = self.get_csr()

                data = {
                    &#39;csr&#39;: csr.decode(),
                    &#39;hostuuid&#39;: self.Config.config[&#39;oitc&#39;][&#39;hostuuid&#39;]
                }
                headers = {
                    &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,
                    &#39;Authorization&#39;: &#39;X-OITC-API &#39; + self.Config.config[&#39;oitc&#39;][&#39;apikey&#39;].strip(),
                }
                if renew:
                    data[&#39;checksum&#39;] = self.get_cert_checksum()

                try:
                    urllib3.disable_warnings()
                except:
                    if self.Config.stacktrace:
                        traceback.print_exc()

                response = requests.post(
                    self.Config.config[&#39;oitc&#39;][&#39;url&#39;].strip() + &#39;/agentconnector/certificate.json&#39;,
                    data=data,
                    headers=headers,
                    verify=False)
                if response.content.decode(&#39;utf-8&#39;).strip() != &#39;&#39;:
                    jdata = json.loads(response.content.decode(&#39;utf-8&#39;))

                    if &#39;checksum_missing&#39; in jdata:
                        self.agent_log.error(&#39;Agent certificate already generated. May be hijacked?&#39;)
                        self.agent_log.info(
                            &#39;Add old certificate checksum to request or recreate Agent in openITCOCKPIT.&#39;
                        )
                        return self.RENEWAL_ERROR

                    if &#39;unknown&#39; in jdata:
                        # self.agent_log.error(
                        #    &#39;Agent state is untrusted! Try again in 1 minute to get a certificate from the server.&#39;
                        # )

                        return self.UNTRUSTED_AGENT

                    if &#39;signed&#39; in jdata and &#39;ca&#39; in jdata:
                        self.store_cert_file(jdata[&#39;signed&#39;])
                        self.store_ca_file(jdata[&#39;ca&#39;])

                        self.agent_log.info(&#39;Certificate updated successfully&#39;)

                        # Successfully get PULLED a new certificate
                        return self.RENEWAL_SUCESSFUL

            except:
                self.agent_log.error(&#39;An error occurred during autossl certificate renewal process&#39;)

                if self.Config.stacktrace:
                    traceback.print_exc()

            else:
                self.agent_log.error(
                    &#39;Agent is not running in PUSH mode or no openITCOCKPIT API Configuration found in config.cnf - Certificate Signing Request not possible&#39;
                )

        # error
        return self.RENEWAL_ERROR

    def get_cert_checksum(self) -&gt; str:
        &#34;&#34;&#34;Returns the current sha512 checksum of the agent certificate&#34;&#34;&#34;

        self.checksum_lock.acquire()
        if self.cert_checksum is None:
            with open(self.Config.config[&#39;default&#39;][&#39;autossl-crt-file&#39;], &#39;rb&#39;) as f:
                cert = f.read()
                # cert = cert.replace(&#34;\r\n&#34;, &#34;\n&#34;)

                sha512 = hashlib.sha512()
                sha512.update(cert)
                self.cert_checksum = sha512.hexdigest().upper()

        cert_checksum = self.cert_checksum
        self.checksum_lock.release()

        #self.agent_log.debug(cert_checksum)
        return cert_checksum

    def store_cert_file(self, cert_data: str) -&gt; bool:
        self.checksum_lock.acquire()
        self.agent_log.info(&#39;Update certificate files&#39;)
        try:
            self.cert_checksum = None

            with open(self.Config.config[&#39;default&#39;][&#39;autossl-crt-file&#39;], &#39;wb+&#39;) as f:
                f.write(cert_data.encode())

                self.checksum_lock.release()
                return True

        except:
            self.agent_log.error(&#34;An error occurred while saving new agent certificate&#34;)
            traceback.print_exc()

            self.checksum_lock.release()
            return False

    def store_ca_file(self, ca_data: str) -&gt; bool:
        self.checksum_lock.acquire()
        self.agent_log.info(&#39;Update CA certificate files&#39;)
        try:
            self.cert_checksum = None

            with open(self.Config.config[&#39;default&#39;][&#39;autossl-ca-file&#39;], &#39;wb+&#39;) as f:
                f.write(ca_data.encode())

                self.checksum_lock.release()
                return True

        except:
            self.agent_log.error(&#34;An error occurred while saving new CA certificate&#34;)
            traceback.print_exc()

            self.checksum_lock.release()
            return False</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="openitcockpit-agent.src.certificates.Certificates"><code class="flex name class">
<span>class <span class="ident">Certificates</span></span>
<span>(</span><span>config, agent_log)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Certificates:
    RENEWAL_SUCESSFUL = 1
    UNTRUSTED_AGENT = 2
    RENEWAL_ERROR = 3

    def __init__(self, config, agent_log):
        self.Config: Config = config
        self.agent_log: AgentLog = agent_log

        self.days_until_cert_warning = 120
        self.days_until_ca_warning = 30

        self.cert_checksum = None
        self.certificate_check_lock = Lock()
        self.checksum_lock = Lock()

    def get_csr(self) -&gt; FILETYPE_PEM:
        &#34;&#34;&#34;Function that creates a new Certificate signing request (CSR)

        Creates a RSA (4096) certificate request.
        The hostname is config[&#39;oitc&#39;][&#39;hostuuid&#39;] + &#39;.agent.oitc&#39;.

        Writes csr in the default or custom autossl-csr-file.

        Writes certificate key in the default or custom autossl-key-file.


        Returns
        -------
        FILETYPE_PEM
            Returns a pem object (FILETYPE_PEM) on success

        &#34;&#34;&#34;

        try:

            # ECC (not working yet)
            #
            # from Crypto.PublicKey import ECC
            #
            # key = ECC.generate(curve=&#39;prime256v1&#39;)
            # req = X509Req()
            # req.get_subject().CN = config[&#39;oitc&#39;][&#39;hostuuid&#39;]+&#39;.agent.oitc&#39;
            # publicKey = key.public_key().export_key(format=&#39;PEM&#39;, compress=False)
            # privateKey = key.export_key(format=&#39;PEM&#39;, compress=False, use_pkcs8=True)
            #
            # pubdict = {}
            # pubdict[&#39;_only_public&#39;] = publicKey
            # req.sign(publicKey, &#39;sha384&#39;)

            self.agent_log.info(&#39;Creating new Certificate Signing Request (CSR)&#39;)

            # create public/private key
            key = PKey()
            key.generate_key(TYPE_RSA, 4096)

            # Generate CSR
            req = X509Req()
            req.get_subject().CN = self.Config.config.get(&#39;oitc&#39;, &#39;hostuuid&#39;) + &#39;.agent.oitc&#39;

            # Experimental; not supported by php agent csr sign method yet
            san_list = [&#34;DNS:localhost&#34;, &#34;DNS:127.0.0.1&#34;]
            req.add_extensions([
                OpenSSL.crypto.X509Extension(b&#34;subjectAltName&#34;, True, (&#34;, &#34;.join(san_list)).encode(&#39;ascii&#39;))
            ])

            # req.get_subject().O = &#39;XYZ Widgets Inc&#39;
            # req.get_subject().OU = &#39;IT Department&#39;
            # req.get_subject().L = &#39;Seattle&#39;
            # req.get_subject().ST = &#39;Washington&#39;
            # req.get_subject().C = &#39;US&#39;
            # req.get_subject().emailAddress = &#39;e@example.com&#39;
            req.set_pubkey(key)

            # b&#39;sha512&#39; will throw an error so we pass a string even if the function docs says it wants a byte string
            req.sign(key, &#39;sha512&#39;)

            ssl_paths = [
                self.Config.config[&#39;default&#39;][&#39;autossl-csr-file&#39;],
                self.Config.config[&#39;default&#39;][&#39;autossl-key-file&#39;],
                self.Config.config[&#39;default&#39;][&#39;autossl-crt-file&#39;],
                self.Config.config[&#39;default&#39;][&#39;autossl-ca-file&#39;]
            ]

            for filename in ssl_paths:
                if not os.path.exists(os.path.dirname(filename)):
                    try:
                        os.makedirs(os.path.dirname(filename))
                    except OSError as exc:  # Guard against race condition
                        if exc.errno != errno.EEXIST:
                            self.agent_log.error(&#39;An error occurred while creating the ssl files containing folders&#39;)
                            if self.Config.stacktrace:
                                raise

            csr = dump_certificate_request(FILETYPE_PEM, req)
            with open(self.Config.config[&#39;default&#39;][&#39;autossl-csr-file&#39;], &#39;wb+&#39;) as f:
                f.write(csr)
            with open(self.Config.config[&#39;default&#39;][&#39;autossl-key-file&#39;], &#39;wb+&#39;) as f:
                f.write(dump_privatekey(FILETYPE_PEM, key))

            self.agent_log.info(&#39;CSR file written&#39;)

            return csr
        except:
            self.agent_log.error(&#39;An error occurred while creating a new Certificate Signing Request (CSR)&#39;)
            traceback.print_exc()

            if self.Config.stacktrace:
                traceback.print_exc()

            return False

    def requires_new_certificate(self) -&gt; bool:
        &#34;&#34;&#34;Checks if new autossl certificates are required if:
         - no agent certificate exists
        &#34;&#34;&#34;

        if self.Config.autossl is False:
            return False

        # Check if agent certificate file exists
        if not Filesystem.file_readable(self.Config.config[&#39;default&#39;][&#39;autossl-crt-file&#39;]):
            self.agent_log.warning(
                &#39;Could not read agent certificate file %s&#39; % self.Config.config[&#39;default&#39;][&#39;autossl-crt-file&#39;]
            )
            return True

        # Check if CA certificate file exists
        if not Filesystem.file_readable(self.Config.config[&#39;default&#39;][&#39;autossl-ca-file&#39;]):
            self.agent_log.warning(
                &#39;Could not read CA certificate file %s&#39; % self.Config.config[&#39;default&#39;][&#39;autossl-ca-file&#39;]
            )
            return True

        return False

    def requires_certificate_renewal(self) -&gt; bool:
        &#34;&#34;&#34;Checks if a autossl certificates requires a renewal:
         - agent certificate expire soon
         - CA certificate expires soon
        &#34;&#34;&#34;

        # Check if agent certificate will expire soon
        with open(self.Config.config[&#39;default&#39;][&#39;autossl-crt-file&#39;], &#39;rb&#39;) as f:
            cert = f.read()
            x509 = load_certificate(FILETYPE_PEM, cert)
            x509info = x509.get_notAfter()
            exp_day = x509info[6:8].decode(&#39;utf-8&#39;)
            exp_month = x509info[4:6].decode(&#39;utf-8&#39;)
            exp_year = x509info[:4].decode(&#39;utf-8&#39;)
            exp_date = str(exp_day) + &#34;-&#34; + str(exp_month) + &#34;-&#34; + str(exp_year)

            self.agent_log.info(&#34;SSL Certificate expires in %s on %s (DD-MM-YYYY)&#34; % (
                str(datetime.date(int(exp_year),
                                  int(exp_month),
                                  int(exp_day)) - datetime.datetime.now().date()).split(&#39;,&#39;)[0], exp_date
            ))

            if datetime.date(int(exp_year), int(exp_month),
                             int(exp_day)) - datetime.datetime.now().date() &lt;= datetime.timedelta(
                self.days_until_cert_warning):
                self.agent_log.warning(
                    &#39;Agent SSL certificate will expire soon. Try to create a new one automatically ...&#39;)
                return True

        # Check if CA certificate will expire soon
        if Filesystem.file_readable(self.Config.config[&#39;default&#39;][&#39;autossl-ca-file&#39;]):
            self.agent_log.info(&#39;CA file %s found and readable&#39; % self.Config.config[&#39;default&#39;][&#39;autossl-ca-file&#39;])
            with open(self.Config.config[&#39;default&#39;][&#39;autossl-ca-file&#39;], &#39;rb&#39;) as f:
                ca = f.read()
                x509 = load_certificate(FILETYPE_PEM, ca)
                x509info = x509.get_notAfter()
                exp_day = x509info[6:8].decode(&#39;utf-8&#39;)
                exp_month = x509info[4:6].decode(&#39;utf-8&#39;)
                exp_year = x509info[:4].decode(&#39;utf-8&#39;)
                exp_date = str(exp_day) + &#34;-&#34; + str(exp_month) + &#34;-&#34; + str(exp_year)

                if datetime.date(int(exp_year), int(exp_month),
                                 int(exp_day)) - datetime.datetime.now().date() &lt;= datetime.timedelta(
                    self.days_until_ca_warning):
                    self.agent_log.warning(&#34;CA Certificate expires in %s on %s (DD-MM-YYYY)&#34; % (
                        str(datetime.date(int(exp_year), int(exp_month),
                                          int(exp_day)) - datetime.datetime.now().date()).split(
                            &#39;,&#39;)[0], exp_date))
                    return True

        return False

    def check_auto_certificate(self) -&gt; bool:
        &#34;&#34;&#34;Function to check the automatically generated certificate

        This function checks if the automatically generated certificate is installed and will otherwise trigger the download.
        In addition it checks if the certificate will expire soon.

        &#34;&#34;&#34;

        self.agent_log.info(&#39;Checking auto TLS certificate&#39;)

        trigger_reload = False
        if self.requires_new_certificate() is True:
            result = self._pull_crt_from_server(renew=False)
            if result == self.RENEWAL_SUCESSFUL:
                trigger_reload = True

            if result == self.UNTRUSTED_AGENT:
                # throw the UntrustedAgentException to the function the calls check_auto_certificate
                # so it can set the certificate check interval to 60 seconds instead of 6 hours
                raise UntrustedAgentException

        if Filesystem.file_readable(self.Config.config[&#39;default&#39;][&#39;autossl-crt-file&#39;]):
            if self.requires_certificate_renewal() is True:
                result = self._pull_crt_from_server(renew=True)
                if result == self.RENEWAL_SUCESSFUL:
                    trigger_reload = True

                if result == self.UNTRUSTED_AGENT:
                    # throw the UntrustedAgentException to the function the calls check_auto_certificate
                    # so it can set the certificate check interval to 60 seconds instead of 6 hours
                    raise UntrustedAgentException

        return trigger_reload

    def _pull_crt_from_server(self, renew=False) -&gt; int:
        &#34;&#34;&#34;Function to pull a new certificate using a Certificate signing request (CSR)

        This function tries to pull a new certificate from the configured openITCOCKPIT Server.
        Therefore a new certificate signing request (CSR) is needed and self.get_csr() will be called.
        The request with the CSR should return the new client and CA certificate.

        If the agent is not yet trusted by the openITCOCKPIT Server a manual confirmation in the openITCOCKPIT frontend is needed!

        If an existing certificate expired, a sha512 checksum has to be sent with the request to the openITCOCKPIT Server.
        With that checksum the server can validate, that the request was sent from a trusted agent (that has access to the old certificate).

        Returns
        -------
        int
        1 = successful =&gt; self.RENEWAL_SUCESSFUL
        2 = untrusted agent =&gt; self.UNTRUSTED_AGENT
        3 = other error =&gt; self.RENEWAL_ERROR
        &#34;&#34;&#34;

        # ONLY PULL cert if Agent is running in PUSH mode!!
        if self.Config.is_push_mode is False:
            return self.RENEWAL_ERROR

        if self.certificate_check_lock.locked():
            self.agent_log.error(&#39;Function to pull a new certificate is locked by another thread!&#39;)
            return self.RENEWAL_ERROR

        # with self.certificate_check_lock is a shortcut for:
        # self.certificate_check_lock.acquire()
        # do_something()
        # self.certificate_check_lock.release()
        with self.certificate_check_lock:
            self.agent_log.info(&#39;Pulling Certificate Signing Request (CSR) file from Server&#39;)

            try:
                csr = self.get_csr()

                data = {
                    &#39;csr&#39;: csr.decode(),
                    &#39;hostuuid&#39;: self.Config.config[&#39;oitc&#39;][&#39;hostuuid&#39;]
                }
                headers = {
                    &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded&#39;,
                    &#39;Authorization&#39;: &#39;X-OITC-API &#39; + self.Config.config[&#39;oitc&#39;][&#39;apikey&#39;].strip(),
                }
                if renew:
                    data[&#39;checksum&#39;] = self.get_cert_checksum()

                try:
                    urllib3.disable_warnings()
                except:
                    if self.Config.stacktrace:
                        traceback.print_exc()

                response = requests.post(
                    self.Config.config[&#39;oitc&#39;][&#39;url&#39;].strip() + &#39;/agentconnector/certificate.json&#39;,
                    data=data,
                    headers=headers,
                    verify=False)
                if response.content.decode(&#39;utf-8&#39;).strip() != &#39;&#39;:
                    jdata = json.loads(response.content.decode(&#39;utf-8&#39;))

                    if &#39;checksum_missing&#39; in jdata:
                        self.agent_log.error(&#39;Agent certificate already generated. May be hijacked?&#39;)
                        self.agent_log.info(
                            &#39;Add old certificate checksum to request or recreate Agent in openITCOCKPIT.&#39;
                        )
                        return self.RENEWAL_ERROR

                    if &#39;unknown&#39; in jdata:
                        # self.agent_log.error(
                        #    &#39;Agent state is untrusted! Try again in 1 minute to get a certificate from the server.&#39;
                        # )

                        return self.UNTRUSTED_AGENT

                    if &#39;signed&#39; in jdata and &#39;ca&#39; in jdata:
                        self.store_cert_file(jdata[&#39;signed&#39;])
                        self.store_ca_file(jdata[&#39;ca&#39;])

                        self.agent_log.info(&#39;Certificate updated successfully&#39;)

                        # Successfully get PULLED a new certificate
                        return self.RENEWAL_SUCESSFUL

            except:
                self.agent_log.error(&#39;An error occurred during autossl certificate renewal process&#39;)

                if self.Config.stacktrace:
                    traceback.print_exc()

            else:
                self.agent_log.error(
                    &#39;Agent is not running in PUSH mode or no openITCOCKPIT API Configuration found in config.cnf - Certificate Signing Request not possible&#39;
                )

        # error
        return self.RENEWAL_ERROR

    def get_cert_checksum(self) -&gt; str:
        &#34;&#34;&#34;Returns the current sha512 checksum of the agent certificate&#34;&#34;&#34;

        self.checksum_lock.acquire()
        if self.cert_checksum is None:
            with open(self.Config.config[&#39;default&#39;][&#39;autossl-crt-file&#39;], &#39;rb&#39;) as f:
                cert = f.read()
                # cert = cert.replace(&#34;\r\n&#34;, &#34;\n&#34;)

                sha512 = hashlib.sha512()
                sha512.update(cert)
                self.cert_checksum = sha512.hexdigest().upper()

        cert_checksum = self.cert_checksum
        self.checksum_lock.release()

        #self.agent_log.debug(cert_checksum)
        return cert_checksum

    def store_cert_file(self, cert_data: str) -&gt; bool:
        self.checksum_lock.acquire()
        self.agent_log.info(&#39;Update certificate files&#39;)
        try:
            self.cert_checksum = None

            with open(self.Config.config[&#39;default&#39;][&#39;autossl-crt-file&#39;], &#39;wb+&#39;) as f:
                f.write(cert_data.encode())

                self.checksum_lock.release()
                return True

        except:
            self.agent_log.error(&#34;An error occurred while saving new agent certificate&#34;)
            traceback.print_exc()

            self.checksum_lock.release()
            return False

    def store_ca_file(self, ca_data: str) -&gt; bool:
        self.checksum_lock.acquire()
        self.agent_log.info(&#39;Update CA certificate files&#39;)
        try:
            self.cert_checksum = None

            with open(self.Config.config[&#39;default&#39;][&#39;autossl-ca-file&#39;], &#39;wb+&#39;) as f:
                f.write(ca_data.encode())

                self.checksum_lock.release()
                return True

        except:
            self.agent_log.error(&#34;An error occurred while saving new CA certificate&#34;)
            traceback.print_exc()

            self.checksum_lock.release()
            return False</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="openitcockpit-agent.src.certificates.Certificates.RENEWAL_ERROR"><code class="name">var <span class="ident">RENEWAL_ERROR</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="openitcockpit-agent.src.certificates.Certificates.RENEWAL_SUCESSFUL"><code class="name">var <span class="ident">RENEWAL_SUCESSFUL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="openitcockpit-agent.src.certificates.Certificates.UNTRUSTED_AGENT"><code class="name">var <span class="ident">UNTRUSTED_AGENT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="openitcockpit-agent.src.certificates.Certificates.check_auto_certificate"><code class="name flex">
<span>def <span class="ident">check_auto_certificate</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Function to check the automatically generated certificate</p>
<p>This function checks if the automatically generated certificate is installed and will otherwise trigger the download.
In addition it checks if the certificate will expire soon.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_auto_certificate(self) -&gt; bool:
    &#34;&#34;&#34;Function to check the automatically generated certificate

    This function checks if the automatically generated certificate is installed and will otherwise trigger the download.
    In addition it checks if the certificate will expire soon.

    &#34;&#34;&#34;

    self.agent_log.info(&#39;Checking auto TLS certificate&#39;)

    trigger_reload = False
    if self.requires_new_certificate() is True:
        result = self._pull_crt_from_server(renew=False)
        if result == self.RENEWAL_SUCESSFUL:
            trigger_reload = True

        if result == self.UNTRUSTED_AGENT:
            # throw the UntrustedAgentException to the function the calls check_auto_certificate
            # so it can set the certificate check interval to 60 seconds instead of 6 hours
            raise UntrustedAgentException

    if Filesystem.file_readable(self.Config.config[&#39;default&#39;][&#39;autossl-crt-file&#39;]):
        if self.requires_certificate_renewal() is True:
            result = self._pull_crt_from_server(renew=True)
            if result == self.RENEWAL_SUCESSFUL:
                trigger_reload = True

            if result == self.UNTRUSTED_AGENT:
                # throw the UntrustedAgentException to the function the calls check_auto_certificate
                # so it can set the certificate check interval to 60 seconds instead of 6 hours
                raise UntrustedAgentException

    return trigger_reload</code></pre>
</details>
</dd>
<dt id="openitcockpit-agent.src.certificates.Certificates.get_cert_checksum"><code class="name flex">
<span>def <span class="ident">get_cert_checksum</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the current sha512 checksum of the agent certificate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_cert_checksum(self) -&gt; str:
    &#34;&#34;&#34;Returns the current sha512 checksum of the agent certificate&#34;&#34;&#34;

    self.checksum_lock.acquire()
    if self.cert_checksum is None:
        with open(self.Config.config[&#39;default&#39;][&#39;autossl-crt-file&#39;], &#39;rb&#39;) as f:
            cert = f.read()
            # cert = cert.replace(&#34;\r\n&#34;, &#34;\n&#34;)

            sha512 = hashlib.sha512()
            sha512.update(cert)
            self.cert_checksum = sha512.hexdigest().upper()

    cert_checksum = self.cert_checksum
    self.checksum_lock.release()

    #self.agent_log.debug(cert_checksum)
    return cert_checksum</code></pre>
</details>
</dd>
<dt id="openitcockpit-agent.src.certificates.Certificates.get_csr"><code class="name flex">
<span>def <span class="ident">get_csr</span></span>(<span>self) ‑> 1</span>
</code></dt>
<dd>
<div class="desc"><p>Function that creates a new Certificate signing request (CSR)</p>
<p>Creates a RSA (4096) certificate request.
The hostname is config['oitc']['hostuuid'] + '.agent.oitc'.</p>
<p>Writes csr in the default or custom autossl-csr-file.</p>
<p>Writes certificate key in the default or custom autossl-key-file.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>FILETYPE_PEM</code></dt>
<dd>Returns a pem object (FILETYPE_PEM) on success</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_csr(self) -&gt; FILETYPE_PEM:
    &#34;&#34;&#34;Function that creates a new Certificate signing request (CSR)

    Creates a RSA (4096) certificate request.
    The hostname is config[&#39;oitc&#39;][&#39;hostuuid&#39;] + &#39;.agent.oitc&#39;.

    Writes csr in the default or custom autossl-csr-file.

    Writes certificate key in the default or custom autossl-key-file.


    Returns
    -------
    FILETYPE_PEM
        Returns a pem object (FILETYPE_PEM) on success

    &#34;&#34;&#34;

    try:

        # ECC (not working yet)
        #
        # from Crypto.PublicKey import ECC
        #
        # key = ECC.generate(curve=&#39;prime256v1&#39;)
        # req = X509Req()
        # req.get_subject().CN = config[&#39;oitc&#39;][&#39;hostuuid&#39;]+&#39;.agent.oitc&#39;
        # publicKey = key.public_key().export_key(format=&#39;PEM&#39;, compress=False)
        # privateKey = key.export_key(format=&#39;PEM&#39;, compress=False, use_pkcs8=True)
        #
        # pubdict = {}
        # pubdict[&#39;_only_public&#39;] = publicKey
        # req.sign(publicKey, &#39;sha384&#39;)

        self.agent_log.info(&#39;Creating new Certificate Signing Request (CSR)&#39;)

        # create public/private key
        key = PKey()
        key.generate_key(TYPE_RSA, 4096)

        # Generate CSR
        req = X509Req()
        req.get_subject().CN = self.Config.config.get(&#39;oitc&#39;, &#39;hostuuid&#39;) + &#39;.agent.oitc&#39;

        # Experimental; not supported by php agent csr sign method yet
        san_list = [&#34;DNS:localhost&#34;, &#34;DNS:127.0.0.1&#34;]
        req.add_extensions([
            OpenSSL.crypto.X509Extension(b&#34;subjectAltName&#34;, True, (&#34;, &#34;.join(san_list)).encode(&#39;ascii&#39;))
        ])

        # req.get_subject().O = &#39;XYZ Widgets Inc&#39;
        # req.get_subject().OU = &#39;IT Department&#39;
        # req.get_subject().L = &#39;Seattle&#39;
        # req.get_subject().ST = &#39;Washington&#39;
        # req.get_subject().C = &#39;US&#39;
        # req.get_subject().emailAddress = &#39;e@example.com&#39;
        req.set_pubkey(key)

        # b&#39;sha512&#39; will throw an error so we pass a string even if the function docs says it wants a byte string
        req.sign(key, &#39;sha512&#39;)

        ssl_paths = [
            self.Config.config[&#39;default&#39;][&#39;autossl-csr-file&#39;],
            self.Config.config[&#39;default&#39;][&#39;autossl-key-file&#39;],
            self.Config.config[&#39;default&#39;][&#39;autossl-crt-file&#39;],
            self.Config.config[&#39;default&#39;][&#39;autossl-ca-file&#39;]
        ]

        for filename in ssl_paths:
            if not os.path.exists(os.path.dirname(filename)):
                try:
                    os.makedirs(os.path.dirname(filename))
                except OSError as exc:  # Guard against race condition
                    if exc.errno != errno.EEXIST:
                        self.agent_log.error(&#39;An error occurred while creating the ssl files containing folders&#39;)
                        if self.Config.stacktrace:
                            raise

        csr = dump_certificate_request(FILETYPE_PEM, req)
        with open(self.Config.config[&#39;default&#39;][&#39;autossl-csr-file&#39;], &#39;wb+&#39;) as f:
            f.write(csr)
        with open(self.Config.config[&#39;default&#39;][&#39;autossl-key-file&#39;], &#39;wb+&#39;) as f:
            f.write(dump_privatekey(FILETYPE_PEM, key))

        self.agent_log.info(&#39;CSR file written&#39;)

        return csr
    except:
        self.agent_log.error(&#39;An error occurred while creating a new Certificate Signing Request (CSR)&#39;)
        traceback.print_exc()

        if self.Config.stacktrace:
            traceback.print_exc()

        return False</code></pre>
</details>
</dd>
<dt id="openitcockpit-agent.src.certificates.Certificates.requires_certificate_renewal"><code class="name flex">
<span>def <span class="ident">requires_certificate_renewal</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if a autossl certificates requires a renewal:
- agent certificate expire soon
- CA certificate expires soon</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def requires_certificate_renewal(self) -&gt; bool:
    &#34;&#34;&#34;Checks if a autossl certificates requires a renewal:
     - agent certificate expire soon
     - CA certificate expires soon
    &#34;&#34;&#34;

    # Check if agent certificate will expire soon
    with open(self.Config.config[&#39;default&#39;][&#39;autossl-crt-file&#39;], &#39;rb&#39;) as f:
        cert = f.read()
        x509 = load_certificate(FILETYPE_PEM, cert)
        x509info = x509.get_notAfter()
        exp_day = x509info[6:8].decode(&#39;utf-8&#39;)
        exp_month = x509info[4:6].decode(&#39;utf-8&#39;)
        exp_year = x509info[:4].decode(&#39;utf-8&#39;)
        exp_date = str(exp_day) + &#34;-&#34; + str(exp_month) + &#34;-&#34; + str(exp_year)

        self.agent_log.info(&#34;SSL Certificate expires in %s on %s (DD-MM-YYYY)&#34; % (
            str(datetime.date(int(exp_year),
                              int(exp_month),
                              int(exp_day)) - datetime.datetime.now().date()).split(&#39;,&#39;)[0], exp_date
        ))

        if datetime.date(int(exp_year), int(exp_month),
                         int(exp_day)) - datetime.datetime.now().date() &lt;= datetime.timedelta(
            self.days_until_cert_warning):
            self.agent_log.warning(
                &#39;Agent SSL certificate will expire soon. Try to create a new one automatically ...&#39;)
            return True

    # Check if CA certificate will expire soon
    if Filesystem.file_readable(self.Config.config[&#39;default&#39;][&#39;autossl-ca-file&#39;]):
        self.agent_log.info(&#39;CA file %s found and readable&#39; % self.Config.config[&#39;default&#39;][&#39;autossl-ca-file&#39;])
        with open(self.Config.config[&#39;default&#39;][&#39;autossl-ca-file&#39;], &#39;rb&#39;) as f:
            ca = f.read()
            x509 = load_certificate(FILETYPE_PEM, ca)
            x509info = x509.get_notAfter()
            exp_day = x509info[6:8].decode(&#39;utf-8&#39;)
            exp_month = x509info[4:6].decode(&#39;utf-8&#39;)
            exp_year = x509info[:4].decode(&#39;utf-8&#39;)
            exp_date = str(exp_day) + &#34;-&#34; + str(exp_month) + &#34;-&#34; + str(exp_year)

            if datetime.date(int(exp_year), int(exp_month),
                             int(exp_day)) - datetime.datetime.now().date() &lt;= datetime.timedelta(
                self.days_until_ca_warning):
                self.agent_log.warning(&#34;CA Certificate expires in %s on %s (DD-MM-YYYY)&#34; % (
                    str(datetime.date(int(exp_year), int(exp_month),
                                      int(exp_day)) - datetime.datetime.now().date()).split(
                        &#39;,&#39;)[0], exp_date))
                return True

    return False</code></pre>
</details>
</dd>
<dt id="openitcockpit-agent.src.certificates.Certificates.requires_new_certificate"><code class="name flex">
<span>def <span class="ident">requires_new_certificate</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if new autossl certificates are required if:
- no agent certificate exists</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def requires_new_certificate(self) -&gt; bool:
    &#34;&#34;&#34;Checks if new autossl certificates are required if:
     - no agent certificate exists
    &#34;&#34;&#34;

    if self.Config.autossl is False:
        return False

    # Check if agent certificate file exists
    if not Filesystem.file_readable(self.Config.config[&#39;default&#39;][&#39;autossl-crt-file&#39;]):
        self.agent_log.warning(
            &#39;Could not read agent certificate file %s&#39; % self.Config.config[&#39;default&#39;][&#39;autossl-crt-file&#39;]
        )
        return True

    # Check if CA certificate file exists
    if not Filesystem.file_readable(self.Config.config[&#39;default&#39;][&#39;autossl-ca-file&#39;]):
        self.agent_log.warning(
            &#39;Could not read CA certificate file %s&#39; % self.Config.config[&#39;default&#39;][&#39;autossl-ca-file&#39;]
        )
        return True

    return False</code></pre>
</details>
</dd>
<dt id="openitcockpit-agent.src.certificates.Certificates.store_ca_file"><code class="name flex">
<span>def <span class="ident">store_ca_file</span></span>(<span>self, ca_data: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store_ca_file(self, ca_data: str) -&gt; bool:
    self.checksum_lock.acquire()
    self.agent_log.info(&#39;Update CA certificate files&#39;)
    try:
        self.cert_checksum = None

        with open(self.Config.config[&#39;default&#39;][&#39;autossl-ca-file&#39;], &#39;wb+&#39;) as f:
            f.write(ca_data.encode())

            self.checksum_lock.release()
            return True

    except:
        self.agent_log.error(&#34;An error occurred while saving new CA certificate&#34;)
        traceback.print_exc()

        self.checksum_lock.release()
        return False</code></pre>
</details>
</dd>
<dt id="openitcockpit-agent.src.certificates.Certificates.store_cert_file"><code class="name flex">
<span>def <span class="ident">store_cert_file</span></span>(<span>self, cert_data: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def store_cert_file(self, cert_data: str) -&gt; bool:
    self.checksum_lock.acquire()
    self.agent_log.info(&#39;Update certificate files&#39;)
    try:
        self.cert_checksum = None

        with open(self.Config.config[&#39;default&#39;][&#39;autossl-crt-file&#39;], &#39;wb+&#39;) as f:
            f.write(cert_data.encode())

            self.checksum_lock.release()
            return True

    except:
        self.agent_log.error(&#34;An error occurred while saving new agent certificate&#34;)
        traceback.print_exc()

        self.checksum_lock.release()
        return False</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="openitcockpit-agent.src" href="index.html">openitcockpit-agent.src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="openitcockpit-agent.src.certificates.Certificates" href="#openitcockpit-agent.src.certificates.Certificates">Certificates</a></code></h4>
<ul class="">
<li><code><a title="openitcockpit-agent.src.certificates.Certificates.RENEWAL_ERROR" href="#openitcockpit-agent.src.certificates.Certificates.RENEWAL_ERROR">RENEWAL_ERROR</a></code></li>
<li><code><a title="openitcockpit-agent.src.certificates.Certificates.RENEWAL_SUCESSFUL" href="#openitcockpit-agent.src.certificates.Certificates.RENEWAL_SUCESSFUL">RENEWAL_SUCESSFUL</a></code></li>
<li><code><a title="openitcockpit-agent.src.certificates.Certificates.UNTRUSTED_AGENT" href="#openitcockpit-agent.src.certificates.Certificates.UNTRUSTED_AGENT">UNTRUSTED_AGENT</a></code></li>
<li><code><a title="openitcockpit-agent.src.certificates.Certificates.check_auto_certificate" href="#openitcockpit-agent.src.certificates.Certificates.check_auto_certificate">check_auto_certificate</a></code></li>
<li><code><a title="openitcockpit-agent.src.certificates.Certificates.get_cert_checksum" href="#openitcockpit-agent.src.certificates.Certificates.get_cert_checksum">get_cert_checksum</a></code></li>
<li><code><a title="openitcockpit-agent.src.certificates.Certificates.get_csr" href="#openitcockpit-agent.src.certificates.Certificates.get_csr">get_csr</a></code></li>
<li><code><a title="openitcockpit-agent.src.certificates.Certificates.requires_certificate_renewal" href="#openitcockpit-agent.src.certificates.Certificates.requires_certificate_renewal">requires_certificate_renewal</a></code></li>
<li><code><a title="openitcockpit-agent.src.certificates.Certificates.requires_new_certificate" href="#openitcockpit-agent.src.certificates.Certificates.requires_new_certificate">requires_new_certificate</a></code></li>
<li><code><a title="openitcockpit-agent.src.certificates.Certificates.store_ca_file" href="#openitcockpit-agent.src.certificates.Certificates.store_ca_file">store_ca_file</a></code></li>
<li><code><a title="openitcockpit-agent.src.certificates.Certificates.store_cert_file" href="#openitcockpit-agent.src.certificates.Certificates.store_cert_file">store_cert_file</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>